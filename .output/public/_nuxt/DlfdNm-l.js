var Zf=Object.defineProperty;var Xf=(r,e,t)=>e in r?Zf(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var et=(r,e,t)=>Xf(r,typeof e!="symbol"?e+"":e,t);import{b as O,l as Jf,m as Qf,B as oc}from"./BGnIl5FR.js";import{g as As,b as Bs,c as Xe}from"./CqWak0B_.js";import{s as ed,b as td,B as ic}from"./DfOv1mK1.js";const nd="modulepreload",rd=function(r,e){return new URL(r,e).href},ac={},fm=function(e,t,n){let s=Promise.resolve();if(t&&t.length>0){const i=document.getElementsByTagName("link"),a=document.querySelector("meta[property=csp-nonce]"),c=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));s=Promise.allSettled(t.map(u=>{if(u=rd(u,n),u in ac)return;ac[u]=!0;const l=u.endsWith(".css"),f=l?'[rel="stylesheet"]':"";if(!!n)for(let b=i.length-1;b>=0;b--){const g=i[b];if(g.href===u&&(!l||g.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${u}"]${f}`))return;const p=document.createElement("link");if(p.rel=l?"stylesheet":nd,l||(p.as="script"),p.crossOrigin="",p.href=u,c&&p.setAttribute("nonce",c),document.head.appendChild(p),l)return new Promise((b,g)=>{p.addEventListener("load",b),p.addEventListener("error",()=>g(new Error(`Unable to preload CSS for ${u}`)))})}))}function o(i){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i}return s.then(i=>{for(const a of i||[])a.status==="rejected"&&o(a.reason);return e().catch(o)})};function cc(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function sd(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function wo(r,...e){if(!sd(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function od(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");cc(r.outputLen),cc(r.blockLen)}function Js(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function id(r,e){wo(r);const t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const xr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ni=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),tn=(r,e)=>r<<32-e|r>>>e;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function ad(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function ta(r){return typeof r=="string"&&(r=ad(r)),wo(r),r}function cd(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];wo(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}let hu=class{clone(){return this._cloneInto()}};function pu(r){const e=n=>r().update(ta(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function gu(r=32){if(xr&&typeof xr.getRandomValues=="function")return xr.getRandomValues(new Uint8Array(r));if(xr&&typeof xr.randomBytes=="function")return xr.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function ud(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}const ld=(r,e,t)=>r&e^~r&t,fd=(r,e,t)=>r&e^r&t^e&t;let yu=class extends hu{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=ni(this.buffer)}update(e){Js(this);const{view:t,buffer:n,blockLen:s}=this;e=ta(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=ni(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Js(this),id(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let f=i;f<s;f++)t[f]=0;ud(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=ni(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)a.setUint32(4*f,l[f],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}};const Ds=BigInt(2**32-1),Ci=BigInt(32);function bu(r,e=!1){return e?{h:Number(r&Ds),l:Number(r>>Ci&Ds)}:{h:Number(r>>Ci&Ds)|0,l:Number(r&Ds)|0}}function dd(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=bu(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const hd=(r,e)=>BigInt(r>>>0)<<Ci|BigInt(e>>>0),pd=(r,e,t)=>r>>>t,gd=(r,e,t)=>r<<32-t|e>>>t,yd=(r,e,t)=>r>>>t|e<<32-t,bd=(r,e,t)=>r<<32-t|e>>>t,wd=(r,e,t)=>r<<64-t|e>>>t-32,md=(r,e,t)=>r>>>t-32|e<<64-t,kd=(r,e)=>e,Sd=(r,e)=>r,xd=(r,e,t)=>r<<t|e>>>32-t,Ed=(r,e,t)=>e<<t|r>>>32-t,Id=(r,e,t)=>e<<t-32|r>>>64-t,vd=(r,e,t)=>r<<t-32|e>>>64-t;function Ad(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Bd=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),_d=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Rd=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Ld=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Td=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),$d=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,ue={fromBig:bu,split:dd,toBig:hd,shrSH:pd,shrSL:gd,rotrSH:yd,rotrSL:bd,rotrBH:wd,rotrBL:md,rotr32H:kd,rotr32L:Sd,rotlSH:xd,rotlSL:Ed,rotlBH:Id,rotlBL:vd,add:Ad,add3L:Bd,add3H:_d,add4L:Rd,add4H:Ld,add5H:$d,add5L:Td},[Pd,Cd]=ue.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Tn=new Uint32Array(80),$n=new Uint32Array(80);let Od=class extends yu{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:f,Fl:h,Gh:p,Gl:b,Hh:g,Hl:d}=this;return[e,t,n,s,o,i,a,c,u,l,f,h,p,b,g,d]}set(e,t,n,s,o,i,a,c,u,l,f,h,p,b,g,d){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=f|0,this.Fl=h|0,this.Gh=p|0,this.Gl=b|0,this.Hh=g|0,this.Hl=d|0}process(e,t){for(let y=0;y<16;y++,t+=4)Tn[y]=e.getUint32(t),$n[y]=e.getUint32(t+=4);for(let y=16;y<80;y++){const I=Tn[y-15]|0,R=$n[y-15]|0,T=ue.rotrSH(I,R,1)^ue.rotrSH(I,R,8)^ue.shrSH(I,R,7),L=ue.rotrSL(I,R,1)^ue.rotrSL(I,R,8)^ue.shrSL(I,R,7),P=Tn[y-2]|0,U=$n[y-2]|0,he=ue.rotrSH(P,U,19)^ue.rotrBH(P,U,61)^ue.shrSH(P,U,6),Q=ue.rotrSL(P,U,19)^ue.rotrBL(P,U,61)^ue.shrSL(P,U,6),V=ue.add4L(L,Q,$n[y-7],$n[y-16]),pe=ue.add4H(V,T,he,Tn[y-7],Tn[y-16]);Tn[y]=pe|0,$n[y]=V|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:f,El:h,Fh:p,Fl:b,Gh:g,Gl:d,Hh:w,Hl:S}=this;for(let y=0;y<80;y++){const I=ue.rotrSH(f,h,14)^ue.rotrSH(f,h,18)^ue.rotrBH(f,h,41),R=ue.rotrSL(f,h,14)^ue.rotrSL(f,h,18)^ue.rotrBL(f,h,41),T=f&p^~f&g,L=h&b^~h&d,P=ue.add5L(S,R,L,Cd[y],$n[y]),U=ue.add5H(P,w,I,T,Pd[y],Tn[y]),he=P|0,Q=ue.rotrSH(n,s,28)^ue.rotrBH(n,s,34)^ue.rotrBH(n,s,39),V=ue.rotrSL(n,s,28)^ue.rotrBL(n,s,34)^ue.rotrBL(n,s,39),pe=n&o^n&a^o&a,_=s&i^s&c^i&c;w=g|0,S=d|0,g=p|0,d=b|0,p=f|0,b=h|0,{h:f,l:h}=ue.add(u|0,l|0,U|0,he|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const $=ue.add3L(he,V,_);n=ue.add3H($,U,Q,pe),s=$|0}({h:n,l:s}=ue.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=ue.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=ue.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=ue.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:f,l:h}=ue.add(this.Eh|0,this.El|0,f|0,h|0),{h:p,l:b}=ue.add(this.Fh|0,this.Fl|0,p|0,b|0),{h:g,l:d}=ue.add(this.Gh|0,this.Gl|0,g|0,d|0),{h:w,l:S}=ue.add(this.Hh|0,this.Hl|0,w|0,S|0),this.set(n,s,o,i,a,c,u,l,f,h,p,b,g,d,w,S)}roundClean(){Tn.fill(0),$n.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};const Ud=pu(()=>new Od);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const na=BigInt(0),mo=BigInt(1),Nd=BigInt(2);function ir(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function _s(r){if(!ir(r))throw new Error("Uint8Array expected")}function Rn(r,e){if(typeof e!="boolean")throw new Error(`${r} must be valid boolean, got "${e}".`)}const zd=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ar(r){_s(r);let e="";for(let t=0;t<r.length;t++)e+=zd[r[t]];return e}function Br(r){const e=r.toString(16);return e.length&1?`0${e}`:e}function ra(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}const mn={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function uc(r){if(r>=mn._0&&r<=mn._9)return r-mn._0;if(r>=mn._A&&r<=mn._F)return r-(mn._A-10);if(r>=mn._a&&r<=mn._f)return r-(mn._a-10)}function Ur(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const i=uc(r.charCodeAt(o)),a=uc(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function rr(r){return ra(ar(r))}function $r(r){return _s(r),ra(ar(Uint8Array.from(r).reverse()))}function Nr(r,e){return Ur(r.toString(16).padStart(e*2,"0"))}function ys(r,e){return Nr(r,e).reverse()}function Dd(r){return Ur(Br(r))}function Je(r,e,t){let n;if(typeof e=="string")try{n=Ur(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(ir(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(`${r} expected ${t} bytes, got ${s}`);return n}function cr(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];_s(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}function Fd(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Md(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}const ri=r=>typeof r=="bigint"&&na<=r;function ko(r,e,t){return ri(r)&&ri(e)&&ri(t)&&e<=r&&r<t}function Ft(r,e,t,n){if(!ko(e,t,n))throw new Error(`expected valid ${r}: ${t} <= n < ${n}, got ${typeof e} ${e}`)}function wu(r){let e;for(e=0;r>na;r>>=mo,e+=1);return e}function Hd(r,e){return r>>BigInt(e)&mo}function Kd(r,e,t){return r|(t?mo:na)<<BigInt(e)}const sa=r=>(Nd<<BigInt(r-1))-mo,si=r=>new Uint8Array(r),lc=r=>Uint8Array.from(r);function mu(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=si(r),s=si(r),o=0;const i=()=>{n.fill(1),s.fill(0),o=0},a=(...f)=>t(s,n,...f),c=(f=si())=>{s=a(lc([0]),f),n=a(),f.length!==0&&(s=a(lc([1]),f),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const h=[];for(;f<e;){n=a();const p=n.slice();h.push(p),f+=n.length}return cr(...h)};return(f,h)=>{i(),c(f);let p;for(;!(p=h(u()));)c();return i(),p}}const Wd={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ir(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function jr(r,e,t={}){const n=(s,o,i)=>{const a=Wd[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(e))n(s,o,!1);for(const[s,o]of Object.entries(t))n(s,o,!0);return r}const qd=()=>{throw new Error("not implemented")};function bs(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const o=r(t,...n);return e.set(t,o),o}}const jd=Object.freeze(Object.defineProperty({__proto__:null,aInRange:Ft,abool:Rn,abytes:_s,bitGet:Hd,bitLen:wu,bitMask:sa,bitSet:Kd,bytesToHex:ar,bytesToNumberBE:rr,bytesToNumberLE:$r,concatBytes:cr,createHmacDrbg:mu,ensureBytes:Je,equalBytes:Fd,hexToBytes:Ur,hexToNumber:ra,inRange:ko,isBytes:ir,memoized:bs,notImplemented:qd,numberToBytesBE:Nr,numberToBytesLE:ys,numberToHexUnpadded:Br,numberToVarBytesBE:Dd,utf8ToBytes:Md,validateObject:jr},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ot=BigInt(0),Ke=BigInt(1),Gn=BigInt(2),Vd=BigInt(3),Oi=BigInt(4),fc=BigInt(5),dc=BigInt(8);BigInt(9);BigInt(16);function ze(r,e){const t=r%e;return t>=ot?t:e+t}function Gd(r,e,t){if(t<=ot||e<ot)throw new Error("Expected power/modulo > 0");if(t===Ke)return ot;let n=Ke;for(;e>ot;)e&Ke&&(n=n*r%t),r=r*r%t,e>>=Ke;return n}function je(r,e,t){let n=r;for(;e-- >ot;)n*=n,n%=t;return n}function Ui(r,e){if(r===ot||e<=ot)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=ze(r,e),n=e,s=ot,o=Ke;for(;t!==ot;){const a=n/t,c=n%t,u=s-o*a;n=t,t=c,s=o,o=u}if(n!==Ke)throw new Error("invert: does not exist");return ze(s,e)}function Yd(r){const e=(r-Ke)/Gn;let t,n,s;for(t=r-Ke,n=0;t%Gn===ot;t/=Gn,n++);for(s=Gn;s<r&&Gd(s,e,r)!==r-Ke;s++);if(n===1){const i=(r+Ke)/Oi;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+Ke)/Gn;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),t),f=a.pow(c,o),h=a.pow(c,t);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let p=1;for(let g=a.sqr(h);p<u&&!a.eql(g,a.ONE);p++)g=a.sqr(g);const b=a.pow(l,Ke<<BigInt(u-p-1));l=a.sqr(b),f=a.mul(f,b),h=a.mul(h,l),u=p}return f}}function Zd(r){if(r%Oi===Vd){const e=(r+Ke)/Oi;return function(n,s){const o=n.pow(s,e);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%dc===fc){const e=(r-fc)/dc;return function(n,s){const o=n.mul(s,Gn),i=n.pow(o,e),a=n.mul(s,i),c=n.mul(n.mul(a,Gn),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return Yd(r)}const Xd=(r,e)=>(ze(r,e)&Ke)===Ke,Jd=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Qd(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Jd.reduce((n,s)=>(n[s]="function",n),e);return jr(r,t)}function eh(r,e,t){if(t<ot)throw new Error("Expected power > 0");if(t===ot)return r.ONE;if(t===Ke)return e;let n=r.ONE,s=e;for(;t>ot;)t&Ke&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Ke;return n}function th(r,e){const t=new Array(e.length),n=e.reduce((o,i,a)=>r.is0(i)?o:(t[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return e.reduceRight((o,i,a)=>r.is0(i)?o:(t[a]=r.mul(o,t[a]),r.mul(o,i)),s),t}function ku(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function So(r,e,t=!1,n={}){if(r<=ot)throw new Error(`Expected Field ORDER > 0, got ${r}`);const{nBitLength:s,nByteLength:o}=ku(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=Zd(r),a=Object.freeze({ORDER:r,BITS:s,BYTES:o,MASK:sa(s),ZERO:ot,ONE:Ke,create:c=>ze(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return ot<=c&&c<r},is0:c=>c===ot,isOdd:c=>(c&Ke)===Ke,neg:c=>ze(-c,r),eql:(c,u)=>c===u,sqr:c=>ze(c*c,r),add:(c,u)=>ze(c+u,r),sub:(c,u)=>ze(c-u,r),mul:(c,u)=>ze(c*u,r),pow:(c,u)=>eh(a,c,u),div:(c,u)=>ze(c*Ui(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>Ui(c,r),sqrt:n.sqrt||(c=>i(a,c)),invertBatch:c=>th(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?ys(c,o):Nr(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?$r(c):rr(c)}});return Object.freeze(a)}function Su(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function xu(r){const e=Su(r);return e+Math.ceil(e/2)}function nh(r,e,t=!1){const n=r.length,s=Su(e),o=xu(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const i=t?rr(r):$r(r),a=ze(i,e-Ke)+Ke;return t?ys(a,s):Nr(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const rh=BigInt(0),oi=BigInt(1),ii=new WeakMap,hc=new WeakMap;function Eu(r,e){const t=(o,i)=>{const a=i.negate();return o?a:i},n=o=>{if(!Number.isSafeInteger(o)||o<=0||o>e)throw new Error(`Wrong window size=${o}, should be [1..${e}]`)},s=o=>{n(o);const i=Math.ceil(e/o)+1,a=2**(o-1);return{windows:i,windowSize:a}};return{constTimeNegate:t,unsafeLadder(o,i){let a=r.ZERO,c=o;for(;i>rh;)i&oi&&(a=a.add(c)),c=c.double(),i>>=oi;return a},precomputeWindow(o,i){const{windows:a,windowSize:c}=s(i),u=[];let l=o,f=l;for(let h=0;h<a;h++){f=l,u.push(f);for(let p=1;p<c;p++)f=f.add(l),u.push(f);l=f.double()}return u},wNAF(o,i,a){const{windows:c,windowSize:u}=s(o);let l=r.ZERO,f=r.BASE;const h=BigInt(2**o-1),p=2**o,b=BigInt(o);for(let g=0;g<c;g++){const d=g*u;let w=Number(a&h);a>>=b,w>u&&(w-=p,a+=oi);const S=d,y=d+Math.abs(w)-1,I=g%2!==0,R=w<0;w===0?f=f.add(t(I,i[S])):l=l.add(t(R,i[y]))}return{p:l,f}},wNAFCached(o,i,a){const c=hc.get(o)||1;let u=ii.get(o);return u||(u=this.precomputeWindow(o,c),c!==1&&ii.set(o,a(u))),this.wNAF(c,u,i)},setWindowSize(o,i){n(i),hc.set(o,i),ii.delete(o)}}}function Iu(r,e,t,n){if(!Array.isArray(t)||!Array.isArray(n)||n.length!==t.length)throw new Error("arrays of points and scalars must have equal length");n.forEach((l,f)=>{if(!e.isValid(l))throw new Error(`wrong scalar at index ${f}`)}),t.forEach((l,f)=>{if(!(l instanceof r))throw new Error(`wrong point at index ${f}`)});const s=wu(BigInt(t.length)),o=s>12?s-3:s>4?s-2:s?2:1,i=(1<<o)-1,a=new Array(i+1).fill(r.ZERO),c=Math.floor((e.BITS-1)/o)*o;let u=r.ZERO;for(let l=c;l>=0;l-=o){a.fill(r.ZERO);for(let h=0;h<n.length;h++){const p=n[h],b=Number(p>>BigInt(l)&BigInt(i));a[b]=a[b].add(t[h])}let f=r.ZERO;for(let h=a.length-1,p=r.ZERO;h>0;h--)p=p.add(a[h]),f=f.add(p);if(u=u.add(f),l!==0)for(let h=0;h<o;h++)u=u.double()}return u}function oa(r){return Qd(r.Fp),jr(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ku(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt(0),Bt=BigInt(1),Fs=BigInt(2),sh=BigInt(8),oh={zip215:!0};function ih(r){const e=oa(r);return jr(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function ah(r){const e=ih(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=Fs<<BigInt(a*8)-Bt,l=t.create,f=So(e.n,e.nBitLength),h=e.uvRatio||((k,m)=>{try{return{isValid:!0,value:t.sqrt(k*t.inv(m))}}catch{return{isValid:!1,value:Vt}}}),p=e.adjustScalarBytes||(k=>k),b=e.domain||((k,m,x)=>{if(Rn("phflag",x),m.length||x)throw new Error("Contexts/pre-hash are not supported");return k});function g(k,m){Ft("coordinate "+k,m,Vt,u)}function d(k){if(!(k instanceof y))throw new Error("ExtendedPoint expected")}const w=bs((k,m)=>{const{ex:x,ey:C,ez:D}=k,F=k.is0();m==null&&(m=F?sh:t.inv(D));const G=l(x*m),Z=l(C*m),Y=l(D*m);if(F)return{x:Vt,y:Bt};if(Y!==Bt)throw new Error("invZ was invalid");return{x:G,y:Z}}),S=bs(k=>{const{a:m,d:x}=e;if(k.is0())throw new Error("bad point: ZERO");const{ex:C,ey:D,ez:F,et:G}=k,Z=l(C*C),Y=l(D*D),re=l(F*F),se=l(re*re),ye=l(Z*m),be=l(re*l(ye+Y)),me=l(se+l(x*l(Z*Y)));if(be!==me)throw new Error("bad point: equation left != right (1)");const ve=l(C*D),Ae=l(F*G);if(ve!==Ae)throw new Error("bad point: equation left != right (2)");return!0});class y{constructor(m,x,C,D){this.ex=m,this.ey=x,this.ez=C,this.et=D,g("x",m),g("y",x),g("z",C),g("t",D),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof y)throw new Error("extended point not allowed");const{x,y:C}=m||{};return g("x",x),g("y",C),new y(x,C,Bt,l(x*C))}static normalizeZ(m){const x=t.invertBatch(m.map(C=>C.ez));return m.map((C,D)=>C.toAffine(x[D])).map(y.fromAffine)}static msm(m,x){return Iu(y,f,m,x)}_setWindowSize(m){T.setWindowSize(this,m)}assertValidity(){S(this)}equals(m){d(m);const{ex:x,ey:C,ez:D}=this,{ex:F,ey:G,ez:Z}=m,Y=l(x*Z),re=l(F*D),se=l(C*Z),ye=l(G*D);return Y===re&&se===ye}is0(){return this.equals(y.ZERO)}negate(){return new y(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:m}=e,{ex:x,ey:C,ez:D}=this,F=l(x*x),G=l(C*C),Z=l(Fs*l(D*D)),Y=l(m*F),re=x+C,se=l(l(re*re)-F-G),ye=Y+G,be=ye-Z,me=Y-G,ve=l(se*be),Ae=l(ye*me),ge=l(se*me),Fe=l(be*ye);return new y(ve,Ae,Fe,ge)}add(m){d(m);const{a:x,d:C}=e,{ex:D,ey:F,ez:G,et:Z}=this,{ex:Y,ey:re,ez:se,et:ye}=m;if(x===BigInt(-1)){const ss=l((F-D)*(re+Y)),os=l((F+D)*(re-Y)),Vn=l(os-ss);if(Vn===Vt)return this.double();const is=l(G*Fs*ye),as=l(Z*Fs*se),cs=as+is,us=os+ss,ls=as-is,Jo=l(cs*Vn),Qo=l(us*ls),ei=l(cs*ls),ti=l(Vn*us);return new y(Jo,Qo,ti,ei)}const be=l(D*Y),me=l(F*re),ve=l(Z*C*ye),Ae=l(G*se),ge=l((D+F)*(Y+re)-be-me),Fe=Ae-ve,qt=Ae+ve,jt=l(me-x*be),Go=l(ge*Fe),Yo=l(qt*jt),Zo=l(ge*jt),Xo=l(Fe*qt);return new y(Go,Yo,Xo,Zo)}subtract(m){return this.add(m.negate())}wNAF(m){return T.wNAFCached(this,m,y.normalizeZ)}multiply(m){const x=m;Ft("scalar",x,Bt,n);const{p:C,f:D}=this.wNAF(x);return y.normalizeZ([C,D])[0]}multiplyUnsafe(m){const x=m;return Ft("scalar",x,Vt,n),x===Vt?R:this.equals(R)||x===Bt?this:this.equals(I)?this.wNAF(x).p:T.unsafeLadder(this,x)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return T.unsafeLadder(this,n).is0()}toAffine(m){return w(this,m)}clearCofactor(){const{h:m}=e;return m===Bt?this:this.multiplyUnsafe(m)}static fromHex(m,x=!1){const{d:C,a:D}=e,F=t.BYTES;m=Je("pointHex",m,F),Rn("zip215",x);const G=m.slice(),Z=m[F-1];G[F-1]=Z&-129;const Y=$r(G),re=x?u:t.ORDER;Ft("pointHex.y",Y,Vt,re);const se=l(Y*Y),ye=l(se-Bt),be=l(C*se-D);let{isValid:me,value:ve}=h(ye,be);if(!me)throw new Error("Point.fromHex: invalid y coordinate");const Ae=(ve&Bt)===Bt,ge=(Z&128)!==0;if(!x&&ve===Vt&&ge)throw new Error("Point.fromHex: x=0 and x_0=1");return ge!==Ae&&(ve=l(-ve)),y.fromAffine({x:ve,y:Y})}static fromPrivateKey(m){return U(m).point}toRawBytes(){const{x:m,y:x}=this.toAffine(),C=ys(x,t.BYTES);return C[C.length-1]|=m&Bt?128:0,C}toHex(){return ar(this.toRawBytes())}}y.BASE=new y(e.Gx,e.Gy,Bt,l(e.Gx*e.Gy)),y.ZERO=new y(Vt,Bt,Bt,Vt);const{BASE:I,ZERO:R}=y,T=Eu(y,a*8);function L(k){return ze(k,n)}function P(k){return L($r(k))}function U(k){const m=a;k=Je("private key",k,m);const x=Je("hashed private key",o(k),2*m),C=p(x.slice(0,m)),D=x.slice(m,2*m),F=P(C),G=I.multiply(F),Z=G.toRawBytes();return{head:C,prefix:D,scalar:F,point:G,pointBytes:Z}}function he(k){return U(k).pointBytes}function Q(k=new Uint8Array,...m){const x=cr(...m);return P(o(b(x,Je("context",k),!!s)))}function V(k,m,x={}){k=Je("message",k),s&&(k=s(k));const{prefix:C,scalar:D,pointBytes:F}=U(m),G=Q(x.context,C,k),Z=I.multiply(G).toRawBytes(),Y=Q(x.context,Z,F,k),re=L(G+Y*D);Ft("signature.s",re,Vt,n);const se=cr(Z,ys(re,t.BYTES));return Je("result",se,a*2)}const pe=oh;function _(k,m,x,C=pe){const{context:D,zip215:F}=C,G=t.BYTES;k=Je("signature",k,2*G),m=Je("message",m),F!==void 0&&Rn("zip215",F),s&&(m=s(m));const Z=$r(k.slice(G,2*G));let Y,re,se;try{Y=y.fromHex(x,F),re=y.fromHex(k.slice(0,G),F),se=I.multiplyUnsafe(Z)}catch{return!1}if(!F&&Y.isSmallOrder())return!1;const ye=Q(D,re.toRawBytes(),Y.toRawBytes(),m);return re.add(Y.multiplyUnsafe(ye)).subtract(se).clearCofactor().equals(y.ZERO)}return I._setWindowSize(8),{CURVE:e,getPublicKey:he,sign:V,verify:_,ExtendedPoint:y,utils:{getExtendedPublicKey:U,randomPrivateKey:()=>i(t.BYTES),precompute(k=8,m=y.BASE){return m._setWindowSize(k),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ia=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),pc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const ch=BigInt(1),gc=BigInt(2);BigInt(3);const uh=BigInt(5),lh=BigInt(8);function fh(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),o=ia,a=r*r%o*r%o,c=je(a,gc,o)*a%o,u=je(c,ch,o)*r%o,l=je(u,uh,o)*u%o,f=je(l,e,o)*l%o,h=je(f,t,o)*f%o,p=je(h,n,o)*h%o,b=je(p,s,o)*p%o,g=je(b,s,o)*p%o,d=je(g,e,o)*l%o;return{pow_p_5_8:je(d,gc,o)*r%o,b2:a}}function dh(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function hh(r,e){const t=ia,n=ze(e*e*e,t),s=ze(n*n*e,t),o=fh(r*s).pow_p_5_8;let i=ze(r*n*o,t);const a=ze(e*i*i,t),c=i,u=ze(i*pc,t),l=a===r,f=a===ze(-r,t),h=a===ze(-r*pc,t);return l&&(i=c),(f||h)&&(i=u),Xd(i,t)&&(i=ze(-i,t)),{isValid:l||f,value:i}}const ph=So(ia,void 0,!0),gh={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ph,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:lh,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ud,randomBytes:gu,adjustScalarBytes:dh,uvRatio:hh},yh=ah(gh);var Ms=ed.Buffer;function bh(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=Ms.from(p)),!Ms.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var b=0,g=0,d=0,w=p.length;d!==w&&p[d]===0;)d++,b++;for(var S=(w-d)*u+1>>>0,y=new Uint8Array(S);d!==w;){for(var I=p[d],R=0,T=S-1;(I!==0||R<g)&&T!==-1;T--,R++)I+=256*y[T]>>>0,y[T]=I%i>>>0,I=I/i>>>0;if(I!==0)throw new Error("Non-zero carry");g=R,d++}for(var L=S-g;L!==S&&y[L]===0;)L++;for(var P=a.repeat(b);L<S;++L)P+=r.charAt(y[L]);return P}function f(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return Ms.alloc(0);for(var b=0,g=0,d=0;p[b]===a;)g++,b++;for(var w=(p.length-b)*c+1>>>0,S=new Uint8Array(w);b<p.length;){var y=e[p.charCodeAt(b)];if(y===255)return;for(var I=0,R=w-1;(y!==0||I<d)&&R!==-1;R--,I++)y+=i*S[R]>>>0,S[R]=y%256>>>0,y=y/256>>>0;if(y!==0)throw new Error("Non-zero carry");d=I,b++}for(var T=w-d;T!==w&&S[T]===0;)T++;var L=Ms.allocUnsafe(g+(w-T));L.fill(0,0,g);for(var P=g;T!==w;)L[P++]=S[T++];return L}function h(p){var b=f(p);if(b)return b;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:f,decode:h}}var vu=bh,wh=vu,mh="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",kh=wh(mh);const yc=As(kh),Sh=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Cn=new Uint32Array(64);let xh=class extends yu{constructor(){super(64,32,8,!1),this.A=Pn[0]|0,this.B=Pn[1]|0,this.C=Pn[2]|0,this.D=Pn[3]|0,this.E=Pn[4]|0,this.F=Pn[5]|0,this.G=Pn[6]|0,this.H=Pn[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let f=0;f<16;f++,t+=4)Cn[f]=e.getUint32(t,!1);for(let f=16;f<64;f++){const h=Cn[f-15],p=Cn[f-2],b=tn(h,7)^tn(h,18)^h>>>3,g=tn(p,17)^tn(p,19)^p>>>10;Cn[f]=g+Cn[f-7]+b+Cn[f-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let f=0;f<64;f++){const h=tn(a,6)^tn(a,11)^tn(a,25),p=l+h+ld(a,c,u)+Sh[f]+Cn[f]|0,g=(tn(n,2)^tn(n,13)^tn(n,22))+fd(n,s,o)|0;l=u,u=c,c=a,a=i+p|0,i=o,o=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){Cn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const Ni=pu(()=>new xh);var ft={},Eh=vu,Ih="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",vh=Eh(Ih);function In(r,e,t){return e<=r&&r<=t}function xo(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function Ah(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function Bh(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var Qs=-1;function aa(r){this.tokens=[].slice.call(r)}aa.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():Qs},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var zr=-1;function ai(r,e){if(r)throw TypeError("Decoder error");return e||65533}var eo="utf-8";function to(r,e){if(!(this instanceof to))return new to(r,e);if(r=r!==void 0?String(r).toLowerCase():eo,r!==eo)throw new Error("Encoding not supported. Only utf-8 is supported");e=xo(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}to.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=xo(t),this._streaming||(this._decoder=new _h({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new aa(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==zr);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===zr)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Bh(o)}};function no(r,e){if(!(this instanceof no))return new no(r,e);if(r=r!==void 0?String(r).toLowerCase():eo,r!==eo)throw new Error("Encoding not supported. Only utf-8 is supported");e=xo(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}no.prototype={encode:function(e,t){e=e?String(e):"",t=xo(t),this._streaming||(this._encoder=new Rh(this._options)),this._streaming=!!t.stream;for(var n=[],s=new aa(Ah(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==zr);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==zr;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function _h(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===Qs&&s!==0)return s=0,ai(e);if(c===Qs)return zr;if(s===0){if(In(c,0,127))return c;if(In(c,194,223))s=1,t=c-192;else if(In(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(In(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return ai(e);return t=t<<6*s,null}if(!In(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),ai(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var u=t;return t=s=n=0,u}}function Rh(r){r.fatal,this.handler=function(e,t){if(t===Qs)return zr;if(In(t,0,127))return t;var n,s;In(t,128,2047)?(n=1,s=192):In(t,2048,65535)?(n=2,s=224):In(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const Lh=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:to,TextEncoder:no},Symbol.toStringTag,{value:"Module"})),Th=Bs(Lh);var $h=Xe&&Xe.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),Ph=Xe&&Xe.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),hn=Xe&&Xe.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},Ch=Xe&&Xe.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&$h(e,r,t);return Ph(e,r),e},Au=Xe&&Xe.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(ft,"__esModule",{value:!0});var Bu=ft.deserializeUnchecked=Pu=ft.deserialize=$u=ft.serialize=ft.BinaryReader=ft.BinaryWriter=ft.BorshError=ft.baseDecode=ft.baseEncode=void 0;const Mn=Au(td),_u=Au(vh),Oh=Ch(Th),Uh=typeof TextDecoder!="function"?Oh.TextDecoder:TextDecoder,Nh=new Uh("utf-8",{fatal:!0});function zh(r){return typeof r=="string"&&(r=O.Buffer.from(r,"utf8")),_u.default.encode(O.Buffer.from(r))}ft.baseEncode=zh;function Dh(r){return O.Buffer.from(_u.default.decode(r))}ft.baseDecode=Dh;const ci=1024;let Et=class extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}};ft.BorshError=Et;let Ru=class{constructor(){this.buf=O.Buffer.alloc(ci),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=O.Buffer.concat([this.buf,O.Buffer.alloc(ci)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Mn.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Mn.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Mn.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Mn.default(e).toArray("le",64)))}writeBuffer(e){this.buf=O.Buffer.concat([O.Buffer.from(this.buf.subarray(0,this.length)),e,O.Buffer.alloc(ci)]),this.length+=e.length}writeString(e){this.maybeResize();const t=O.Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(O.Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}};ft.BinaryWriter=Ru;function pn(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new Et("Reached the end of buffer when deserializing")}throw o}}}let Ut=class{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new Mn.default(e,"le")}readU128(){const e=this.readBuffer(16);return new Mn.default(e,"le")}readU256(){const e=this.readBuffer(32);return new Mn.default(e,"le")}readU512(){const e=this.readBuffer(64);return new Mn.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Et(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Nh.decode(t)}catch(n){throw new Et(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}};hn([pn],Ut.prototype,"readU8",null);hn([pn],Ut.prototype,"readU16",null);hn([pn],Ut.prototype,"readU32",null);hn([pn],Ut.prototype,"readU64",null);hn([pn],Ut.prototype,"readU128",null);hn([pn],Ut.prototype,"readU256",null);hn([pn],Ut.prototype,"readU512",null);hn([pn],Ut.prototype,"readString",null);hn([pn],Ut.prototype,"readFixedArray",null);hn([pn],Ut.prototype,"readArray",null);ft.BinaryReader=Ut;function Lu(r){return r.charAt(0).toUpperCase()+r.slice(1)}function Yn(r,e,t,n,s){try{if(typeof n=="string")s[`write${Lu(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Et(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new Et(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)Yn(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{Yn(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),Yn(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{Yn(r,e,i,n.key,s),Yn(r,e,o,n.value,s)});break}default:throw new Et(`FieldType ${n} unrecognized`)}else Tu(r,t,s)}catch(o){throw o instanceof Et&&o.addToFieldPath(e),o}}function Tu(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new Et(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{Yn(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),Yn(r,i,e[i],a,t);break}}}else throw new Et(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Fh(r,e,t=Ru){const n=new t;return Tu(r,e,n),n.toArray()}var $u=ft.serialize=Fh;function Zn(r,e,t,n){try{if(typeof t=="string")return n[`read${Lu(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(Zn(r,null,t[0],n));return s}else return n.readArray(()=>Zn(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?Zn(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=Zn(r,e,t.key,n),c=Zn(r,e,t.value,n);s.set(a,c)}return s}return ca(r,t,n)}catch(s){throw s instanceof Et&&s.addToFieldPath(e),s}}function ca(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new Et(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=Zn(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new Et(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=Zn(r,o,i,t);return new e({[o]:a})}throw new Et(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Mh(r,e,t,n=Ut){const s=new n(t),o=ca(r,e,s);if(s.offset<t.length)throw new Et(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Pu=ft.deserialize=Mh;function Hh(r,e,t,n=Ut){const s=new n(t);return ca(r,e,s)}Bu=ft.deserializeUnchecked=Hh;var A={};Object.defineProperty(A,"__esModule",{value:!0});A.s16=A.s8=A.nu64be=A.u48be=A.u40be=A.u32be=A.u24be=A.u16be=ut=A.nu64=A.u48=A.u40=oe=A.u32=A.u24=zt=A.u16=Ze=A.u8=sr=A.offset=A.greedy=A.Constant=A.UTF8=A.CString=A.Blob=A.Boolean=A.BitField=A.BitStructure=A.VariantLayout=A.Union=A.UnionLayoutDiscriminator=A.UnionDiscriminator=A.Structure=A.Sequence=A.DoubleBE=A.Double=A.FloatBE=A.Float=A.NearInt64BE=A.NearInt64=A.NearUInt64BE=A.NearUInt64=A.IntBE=A.Int=A.UIntBE=A.UInt=A.OffsetLayout=A.GreedyCount=A.ExternalLayout=A.bindConstructorLayout=A.nameWithProperty=A.Layout=A.uint8ArrayToBuffer=A.checkUint8Array=void 0;A.constant=A.utf8=A.cstr=Dr=A.blob=A.unionLayoutDiscriminator=A.union=tr=A.seq=A.bits=ie=A.struct=A.f64be=A.f64=A.f32be=A.f32=A.ns64be=A.s48be=A.s40be=A.s32be=A.s24be=A.s16be=Pt=A.ns64=A.s48=A.s40=A.s32=A.s24=void 0;const ua=O;function Vr(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}A.checkUint8Array=Vr;function Ee(r){return Vr(r),ua.Buffer.from(r.buffer,r.byteOffset,r.length)}A.uint8ArrayToBuffer=Ee;let Le=class{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}};A.Layout=Le;function la(r,e){return e.property?r+"["+e.property+"]":r}A.nameWithProperty=la;function Kh(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof Le))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}A.bindConstructorLayout=Kh;let Tt=class extends Le{isCount(){throw new Error("ExternalLayout is abstract")}};A.ExternalLayout=Tt;let Cu=class extends Tt{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Vr(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}};A.GreedyCount=Cu;let fa=class extends Tt{constructor(e,t=0,n){if(!(e instanceof Le))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Ht||this.layout instanceof Yt}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}};A.OffsetLayout=fa;let Ht=class extends Le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ee(e).readUIntLE(t,this.span)}encode(e,t,n=0){return Ee(t).writeUIntLE(e,n,this.span),this.span}};A.UInt=Ht;let Yt=class extends Le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ee(e).readUIntBE(t,this.span)}encode(e,t,n=0){return Ee(t).writeUIntBE(e,n,this.span),this.span}};A.UIntBE=Yt;let pr=class extends Le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ee(e).readIntLE(t,this.span)}encode(e,t,n=0){return Ee(t).writeIntLE(e,n,this.span),this.span}};A.Int=pr;let Gr=class extends Le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ee(e).readIntBE(t,this.span)}encode(e,t,n=0){return Ee(t).writeIntBE(e,n,this.span),this.span}};A.IntBE=Gr;const zi=Math.pow(2,32);function Eo(r){const e=Math.floor(r/zi),t=r-e*zi;return{hi32:e,lo32:t}}function Io(r,e){return r*zi+e}let Ou=class extends Le{constructor(e){super(8,e)}decode(e,t=0){const n=Ee(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return Io(o,s)}encode(e,t,n=0){const s=Eo(e),o=Ee(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}};A.NearUInt64=Ou;let Uu=class extends Le{constructor(e){super(8,e)}decode(e,t=0){const n=Ee(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return Io(s,o)}encode(e,t,n=0){const s=Eo(e),o=Ee(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}};A.NearUInt64BE=Uu;let Nu=class extends Le{constructor(e){super(8,e)}decode(e,t=0){const n=Ee(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return Io(o,s)}encode(e,t,n=0){const s=Eo(e),o=Ee(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}};A.NearInt64=Nu;let zu=class extends Le{constructor(e){super(8,e)}decode(e,t=0){const n=Ee(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return Io(s,o)}encode(e,t,n=0){const s=Eo(e),o=Ee(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}};A.NearInt64BE=zu;let Du=class extends Le{constructor(e){super(4,e)}decode(e,t=0){return Ee(e).readFloatLE(t)}encode(e,t,n=0){return Ee(t).writeFloatLE(e,n),4}};A.Float=Du;let Fu=class extends Le{constructor(e){super(4,e)}decode(e,t=0){return Ee(e).readFloatBE(t)}encode(e,t,n=0){return Ee(t).writeFloatBE(e,n),4}};A.FloatBE=Fu;let Mu=class extends Le{constructor(e){super(8,e)}decode(e,t=0){return Ee(e).readDoubleLE(t)}encode(e,t,n=0){return Ee(t).writeDoubleLE(e,n),8}};A.Double=Mu;let Hu=class extends Le{constructor(e){super(8,e)}decode(e,t=0){return Ee(e).readDoubleBE(t)}encode(e,t,n=0){return Ee(t).writeDoubleBE(e,n),8}};A.DoubleBE=Hu;let Ku=class extends Le{constructor(e,t,n){if(!(e instanceof Le))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Tt&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof Tt)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof Tt&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof Tt&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof Tt&&this.count.encode(e.length,t,n),o}};A.Sequence=Ku;let Wu=class extends Le{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof Le,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Vr(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}};A.Structure=Wu;let da=class{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}};A.UnionDiscriminator=da;let ro=class extends da{constructor(e,t){if(!(e instanceof Tt&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}};A.UnionLayoutDiscriminator=ro;let ha=class extends Le{constructor(e,t,n){let s;if(e instanceof Ht||e instanceof Yt)s=new ro(new fa(e));else if(e instanceof Tt&&e.isCount())s=new ro(e);else if(e instanceof da)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof Le))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof Ht||e instanceof Yt)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Ht||e instanceof Yt,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new qu(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}};A.Union=ha;let qu=class extends Le{constructor(e,t,n,s){if(!(e instanceof ha))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof Le))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}};A.VariantLayout=qu;function Ir(r){return 0>r&&(r+=4294967296),r}let pa=class extends Le{constructor(e,t,n){if(!(e instanceof Ht||e instanceof Yt))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Ir(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new ga(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new ju(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}};A.BitStructure=pa;let ga=class{constructor(e,t,n){if(!(e instanceof pa))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Ir(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return Ir(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Ir(e&this.valueMask))throw new TypeError(la("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=Ir(e<<this.start);this.container._packedSetValue(Ir(t&~this.wordMask)|n)}};A.BitField=ga;let ju=class extends ga{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};A.Boolean=ju;let Vu=class extends Le{constructor(e,t){if(!(e instanceof Tt&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Tt||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),Ee(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof Tt&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(la("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=Ee(e);return Ee(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof Tt&&this.length.encode(s,t,n),s}};A.Blob=Vu;let Gu=class extends Le{constructor(e){super(-1,e)}getSpan(e,t=0){Vr(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return Ee(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=ua.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=Ee(t);return s.copy(i,n),i[n+o]=0,o+1}};A.CString=Gu;let Yu=class extends Le{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Vr(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return Ee(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=ua.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(Ee(t),n),o}};A.UTF8=Yu;let Zu=class extends Le{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}};A.Constant=Zu;A.greedy=(r,e)=>new Cu(r,e);var sr=A.offset=(r,e,t)=>new fa(r,e,t),Ze=A.u8=r=>new Ht(1,r),zt=A.u16=r=>new Ht(2,r);A.u24=r=>new Ht(3,r);var oe=A.u32=r=>new Ht(4,r);A.u40=r=>new Ht(5,r);A.u48=r=>new Ht(6,r);var ut=A.nu64=r=>new Ou(r);A.u16be=r=>new Yt(2,r);A.u24be=r=>new Yt(3,r);A.u32be=r=>new Yt(4,r);A.u40be=r=>new Yt(5,r);A.u48be=r=>new Yt(6,r);A.nu64be=r=>new Uu(r);A.s8=r=>new pr(1,r);A.s16=r=>new pr(2,r);A.s24=r=>new pr(3,r);A.s32=r=>new pr(4,r);A.s40=r=>new pr(5,r);A.s48=r=>new pr(6,r);var Pt=A.ns64=r=>new Nu(r);A.s16be=r=>new Gr(2,r);A.s24be=r=>new Gr(3,r);A.s32be=r=>new Gr(4,r);A.s40be=r=>new Gr(5,r);A.s48be=r=>new Gr(6,r);A.ns64be=r=>new zu(r);A.f32=r=>new Du(r);A.f32be=r=>new Fu(r);A.f64=r=>new Mu(r);A.f64be=r=>new Hu(r);var ie=A.struct=(r,e,t)=>new Wu(r,e,t);A.bits=(r,e,t)=>new pa(r,e,t);var tr=A.seq=(r,e,t)=>new Ku(r,e,t);A.union=(r,e,t)=>new ha(r,e,t);A.unionLayoutDiscriminator=(r,e)=>new ro(r,e);var Dr=A.blob=(r,e)=>new Vu(r,e);A.cstr=r=>new Gu(r);A.utf8=(r,e)=>new Yu(r,e);A.constant=(r,e)=>new Zu(r,e);var Rs={};Object.defineProperty(Rs,"__esModule",{value:!0});function Wh(r){{const e=O.Buffer.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var qh=Rs.toBigIntLE=Wh;function jh(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Rs.toBigIntBE=jh;function Vh(r,e){{const t=r.toString(16),n=O.Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var Gh=Rs.toBufferLE=Vh;function Yh(r,e){{const t=r.toString(16);return O.Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Rs.toBufferBE=Yh;let Zh=class extends TypeError{constructor(e,t){let n;const{message:s,explanation:o,...i}=e,{path:a}=e,c=a.length===0?s:`At path: ${a.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}};function Xh(r){return Ls(r)&&typeof r[Symbol.iterator]=="function"}function Ls(r){return typeof r=="object"&&r!=null}function so(r){return Ls(r)&&!Array.isArray(r)}function Xt(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function Jh(r){const{done:e,value:t}=r.next();return e?void 0:t}function Qh(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${Xt(n)}\``}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*bc(r,e,t,n){Xh(r)||(r=[r]);for(const s of r){const o=Qh(s,e,t,n);o&&(yield o)}}function*ya(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s,mask:i};o&&(r=e.coercer(r,a));let c="valid";for(const u of e.validator(r,a))u.explanation=t.message,c="not_valid",yield[u,void 0];for(let[u,l,f]of e.entries(r,a)){const h=ya(l,f,{path:u===void 0?n:[...n,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i,message:t.message});for(const p of h)p[0]?(c=p[0].refinement!=null?"not_refined":"not_valid",yield[p[0],void 0]):o&&(l=p[1],u===void 0?r=l:r instanceof Map?r.set(u,l):r instanceof Set?r.add(l):Ls(r)&&(l!==void 0||u in r)&&(r[u]=l))}if(c!=="not_valid")for(const u of e.refiner(r,a))u.explanation=t.message,c="not_refined",yield[u,void 0];c==="valid"&&(yield[void 0,r])}let gn=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return bc(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return bc(l,u,this,c)}:this.refiner=()=>[]}assert(e,t){return ep(e,this,t)}create(e,t){return ws(e,this,t)}is(e){return Xu(e,this)}mask(e,t){return tp(e,this,t)}validate(e,t={}){return Ts(e,this,t)}};function ep(r,e,t){const n=Ts(r,e,{message:t});if(n[0])throw n[0]}function ws(r,e,t){const n=Ts(r,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function tp(r,e,t){const n=Ts(r,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Xu(r,e){return!Ts(r,e)[0]}function Ts(r,e,t={}){const n=ya(r,e,t),s=Jh(n);return s[0]?[new Zh(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function gr(r,e){return new gn({type:r,schema:null,validator:e})}function np(){return gr("any",()=>!0)}function X(r){return new gn({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${Xt(e)}`}})}function fn(){return gr("boolean",r=>typeof r=="boolean")}function ba(r){return gr("instance",e=>e instanceof r||`Expected a \`${r.name}\` instance, but received: ${Xt(e)}`)}function Me(r){const e=Xt(r),t=typeof r;return new gn({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${e}\`, but received: ${Xt(n)}`}})}function rp(){return gr("never",()=>!1)}function J(r){return new gn({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function v(){return gr("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${Xt(r)}`)}function ae(r){return new gn({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function Ju(r,e){return new gn({type:"record",schema:null,*entries(t){if(Ls(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return so(t)||`Expected an object, but received: ${Xt(t)}`},coercer(t){return so(t)?{...t}:t}})}function H(){return gr("string",r=>typeof r=="string"||`Expected a string, but received: ${Xt(r)}`)}function wa(r){const e=rp();return new gn({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Xt(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function N(r){const e=Object.keys(r);return new gn({type:"type",schema:r,*entries(t){if(Ls(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return so(t)||`Expected an object, but received: ${Xt(t)}`},coercer(t){return so(t)?{...t}:t}})}function vt(r){const e=r.map(t=>t.type).join(" | ");return new gn({type:"union",schema:null,coercer(t,n){for(const s of r){const[o,i]=s.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){const s=[];for(const o of r){const[...i]=ya(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${Xt(t)}`,...s]}})}function Yr(){return gr("unknown",()=>!0)}function $s(r,e,t){return new gn({...r,coercer:(n,s)=>Xu(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}var Hs,sp=new Uint8Array(16);function Qu(){if(!Hs&&(Hs=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!Hs))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Hs(sp)}const op=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function vo(r){return typeof r=="string"&&op.test(r)}var at=[];for(var ui=0;ui<256;++ui)at.push((ui+256).toString(16).substr(1));function Ao(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(at[r[e+0]]+at[r[e+1]]+at[r[e+2]]+at[r[e+3]]+"-"+at[r[e+4]]+at[r[e+5]]+"-"+at[r[e+6]]+at[r[e+7]]+"-"+at[r[e+8]]+at[r[e+9]]+"-"+at[r[e+10]]+at[r[e+11]]+at[r[e+12]]+at[r[e+13]]+at[r[e+14]]+at[r[e+15]]).toLowerCase();if(!vo(t))throw TypeError("Stringified UUID is invalid");return t}var wc,li,fi=0,di=0;function ip(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||wc,i=r.clockseq!==void 0?r.clockseq:li;if(o==null||i==null){var a=r.random||(r.rng||Qu)();o==null&&(o=wc=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=li=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),u=r.nsecs!==void 0?r.nsecs:di+1,l=c-fi+(u-di)/1e4;if(l<0&&r.clockseq===void 0&&(i=i+1&16383),(l<0||c>fi)&&r.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");fi=c,di=u,li=i,c+=122192928e5;var f=((c&268435455)*1e4+u)%4294967296;s[n++]=f>>>24&255,s[n++]=f>>>16&255,s[n++]=f>>>8&255,s[n++]=f&255;var h=c/4294967296*1e4&268435455;s[n++]=h>>>8&255,s[n++]=h&255,s[n++]=h>>>24&15|16,s[n++]=h>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var p=0;p<6;++p)s[n+p]=o[p];return e||Ao(s)}function el(r){if(!vo(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function ap(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var cp="6ba7b810-9dad-11d1-80b4-00c04fd430c8",up="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function tl(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=ap(s)),typeof o=="string"&&(o=el(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return Ao(c)}try{n.name=r}catch{}return n.DNS=cp,n.URL=up,n}function lp(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return fp(dp(hp(r),r.length*8))}function fp(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function nl(r){return(r+64>>>9<<4)+14+1}function dp(r,e){r[e>>5]|=128<<e%32,r[nl(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,u=s,l=o;t=gt(t,n,s,o,r[i],7,-680876936),o=gt(o,t,n,s,r[i+1],12,-389564586),s=gt(s,o,t,n,r[i+2],17,606105819),n=gt(n,s,o,t,r[i+3],22,-1044525330),t=gt(t,n,s,o,r[i+4],7,-176418897),o=gt(o,t,n,s,r[i+5],12,1200080426),s=gt(s,o,t,n,r[i+6],17,-1473231341),n=gt(n,s,o,t,r[i+7],22,-45705983),t=gt(t,n,s,o,r[i+8],7,1770035416),o=gt(o,t,n,s,r[i+9],12,-1958414417),s=gt(s,o,t,n,r[i+10],17,-42063),n=gt(n,s,o,t,r[i+11],22,-1990404162),t=gt(t,n,s,o,r[i+12],7,1804603682),o=gt(o,t,n,s,r[i+13],12,-40341101),s=gt(s,o,t,n,r[i+14],17,-1502002290),n=gt(n,s,o,t,r[i+15],22,1236535329),t=yt(t,n,s,o,r[i+1],5,-165796510),o=yt(o,t,n,s,r[i+6],9,-1069501632),s=yt(s,o,t,n,r[i+11],14,643717713),n=yt(n,s,o,t,r[i],20,-373897302),t=yt(t,n,s,o,r[i+5],5,-701558691),o=yt(o,t,n,s,r[i+10],9,38016083),s=yt(s,o,t,n,r[i+15],14,-660478335),n=yt(n,s,o,t,r[i+4],20,-405537848),t=yt(t,n,s,o,r[i+9],5,568446438),o=yt(o,t,n,s,r[i+14],9,-1019803690),s=yt(s,o,t,n,r[i+3],14,-187363961),n=yt(n,s,o,t,r[i+8],20,1163531501),t=yt(t,n,s,o,r[i+13],5,-1444681467),o=yt(o,t,n,s,r[i+2],9,-51403784),s=yt(s,o,t,n,r[i+7],14,1735328473),n=yt(n,s,o,t,r[i+12],20,-1926607734),t=bt(t,n,s,o,r[i+5],4,-378558),o=bt(o,t,n,s,r[i+8],11,-2022574463),s=bt(s,o,t,n,r[i+11],16,1839030562),n=bt(n,s,o,t,r[i+14],23,-35309556),t=bt(t,n,s,o,r[i+1],4,-1530992060),o=bt(o,t,n,s,r[i+4],11,1272893353),s=bt(s,o,t,n,r[i+7],16,-155497632),n=bt(n,s,o,t,r[i+10],23,-1094730640),t=bt(t,n,s,o,r[i+13],4,681279174),o=bt(o,t,n,s,r[i],11,-358537222),s=bt(s,o,t,n,r[i+3],16,-722521979),n=bt(n,s,o,t,r[i+6],23,76029189),t=bt(t,n,s,o,r[i+9],4,-640364487),o=bt(o,t,n,s,r[i+12],11,-421815835),s=bt(s,o,t,n,r[i+15],16,530742520),n=bt(n,s,o,t,r[i+2],23,-995338651),t=wt(t,n,s,o,r[i],6,-198630844),o=wt(o,t,n,s,r[i+7],10,1126891415),s=wt(s,o,t,n,r[i+14],15,-1416354905),n=wt(n,s,o,t,r[i+5],21,-57434055),t=wt(t,n,s,o,r[i+12],6,1700485571),o=wt(o,t,n,s,r[i+3],10,-1894986606),s=wt(s,o,t,n,r[i+10],15,-1051523),n=wt(n,s,o,t,r[i+1],21,-2054922799),t=wt(t,n,s,o,r[i+8],6,1873313359),o=wt(o,t,n,s,r[i+15],10,-30611744),s=wt(s,o,t,n,r[i+6],15,-1560198380),n=wt(n,s,o,t,r[i+13],21,1309151649),t=wt(t,n,s,o,r[i+4],6,-145523070),o=wt(o,t,n,s,r[i+11],10,-1120210379),s=wt(s,o,t,n,r[i+2],15,718787259),n=wt(n,s,o,t,r[i+9],21,-343485551),t=Hn(t,a),n=Hn(n,c),s=Hn(s,u),o=Hn(o,l)}return[t,n,s,o]}function hp(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(nl(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function Hn(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function pp(r,e){return r<<e|r>>>32-e}function Bo(r,e,t,n,s,o){return Hn(pp(Hn(Hn(e,r),Hn(n,o)),s),t)}function gt(r,e,t,n,s,o,i){return Bo(e&t|~e&n,r,e,s,o,i)}function yt(r,e,t,n,s,o,i){return Bo(e&n|t&~n,r,e,s,o,i)}function bt(r,e,t,n,s,o,i){return Bo(e^t^n,r,e,s,o,i)}function wt(r,e,t,n,s,o,i){return Bo(t^(e|~n),r,e,s,o,i)}var gp=tl("v3",48,lp);function yp(r,e,t){r=r||{};var n=r.random||(r.rng||Qu)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return Ao(n)}function bp(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function hi(r,e){return r<<e|r>>>32-e}function wp(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=r[c*64+l*4]<<24|r[c*64+l*4+1]<<16|r[c*64+l*4+2]<<8|r[c*64+l*4+3];a[c]=u}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var f=0;f<i;++f){for(var h=new Uint32Array(80),p=0;p<16;++p)h[p]=a[f][p];for(var b=16;b<80;++b)h[b]=hi(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);for(var g=t[0],d=t[1],w=t[2],S=t[3],y=t[4],I=0;I<80;++I){var R=Math.floor(I/20),T=hi(g,5)+bp(R,d,w,S)+y+e[R]+h[I]>>>0;y=S,S=w,w=hi(d,30)>>>0,d=g,g=T}t[0]=t[0]+g>>>0,t[1]=t[1]+d>>>0,t[2]=t[2]+w>>>0,t[3]=t[3]+S>>>0,t[4]=t[4]+y>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var mp=tl("v5",80,wp);const kp="00000000-0000-0000-0000-000000000000";function Sp(r){if(!vo(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const xp=Object.freeze(Object.defineProperty({__proto__:null,NIL:kp,parse:el,stringify:Ao,v1:ip,v3:gp,v4:yp,v5:mp,validate:vo,version:Sp},Symbol.toStringTag,{value:"Module"})),rl=Bs(xp),Ep=rl.v4,Ip=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return Ep()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var vp=Ip;const Ap=rl.v4,Bp=vp,oo=function(r,e){if(!(this instanceof oo))return new oo(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Ap()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};oo.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=Bp(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return n(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,n)}),o};oo.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};var _p={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function o(c,u,l,f,h){if(typeof l!="function")throw new TypeError("The listener must be a function");var p=new s(l,f||c,h),b=t?t+u:u;return c._events[b]?c._events[b].fn?c._events[b]=[c._events[b],p]:c._events[b].push(p):(c._events[b]=p,c._eventsCount++),c}function i(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,f;if(this._eventsCount===0)return u;for(f in l=this._events)e.call(l,f)&&u.push(t?f.slice(1):f);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,f=this._events[l];if(!f)return[];if(f.fn)return[f.fn];for(var h=0,p=f.length,b=new Array(p);h<p;h++)b[h]=f[h].fn;return b},a.prototype.listenerCount=function(u){var l=t?t+u:u,f=this._events[l];return f?f.fn?1:f.length:0},a.prototype.emit=function(u,l,f,h,p,b){var g=t?t+u:u;if(!this._events[g])return!1;var d=this._events[g],w=arguments.length,S,y;if(d.fn){switch(d.once&&this.removeListener(u,d.fn,void 0,!0),w){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,l),!0;case 3:return d.fn.call(d.context,l,f),!0;case 4:return d.fn.call(d.context,l,f,h),!0;case 5:return d.fn.call(d.context,l,f,h,p),!0;case 6:return d.fn.call(d.context,l,f,h,p,b),!0}for(y=1,S=new Array(w-1);y<w;y++)S[y-1]=arguments[y];d.fn.apply(d.context,S)}else{var I=d.length,R;for(y=0;y<I;y++)switch(d[y].once&&this.removeListener(u,d[y].fn,void 0,!0),w){case 1:d[y].fn.call(d[y].context);break;case 2:d[y].fn.call(d[y].context,l);break;case 3:d[y].fn.call(d[y].context,l,f);break;case 4:d[y].fn.call(d[y].context,l,f,h);break;default:if(!S)for(R=1,S=new Array(w-1);R<w;R++)S[R-1]=arguments[R];d[y].fn.apply(d[y].context,S)}}return!0},a.prototype.on=function(u,l,f){return o(this,u,l,f,!1)},a.prototype.once=function(u,l,f){return o(this,u,l,f,!0)},a.prototype.removeListener=function(u,l,f,h){var p=t?t+u:u;if(!this._events[p])return this;if(!l)return i(this,p),this;var b=this._events[p];if(b.fn)b.fn===l&&(!h||b.once)&&(!f||b.context===f)&&i(this,p);else{for(var g=0,d=[],w=b.length;g<w;g++)(b[g].fn!==l||h&&!b[g].once||f&&b[g].context!==f)&&d.push(b[g]);d.length?this._events[p]=d.length===1?d[0]:d:i(this,p)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&i(this,l)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(_p);let sl=class extends hu{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,od(e);const n=ta(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return Js(this),this.iHash.update(e),this}digestInto(e){Js(this),wo(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const ol=(r,e,t)=>new sl(r,e).update(t).digest();ol.create=(r,e)=>new sl(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function mc(r){r.lowS!==void 0&&Rn("lowS",r.lowS),r.prehash!==void 0&&Rn("prehash",r.prehash)}function Rp(r){const e=oa(r);jr(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Lp,hexToBytes:Tp}=jd,xn={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(r,e)=>{const{Err:t}=xn;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=Br(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const o=n>127?Br(s.length/2|128):"";return`${Br(r)}${o}${s}${e}`},decode(r,e){const{Err:t}=xn;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+c);if(u.length!==c)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const l of u)i=i<<8|l;if(n+=c,i<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(r){const{Err:e}=xn;if(r<vn)throw new e("integer: negative integers are not allowed");let t=Br(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected assertion");return t},decode(r){const{Err:e}=xn;if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return Lp(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=xn,s=typeof r=="string"?Tp(r):r;_s(s);const{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("Invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:u,l}=n.decode(2,c);if(l.length)throw new e("Invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(r){const{_tlv:e,_int:t}=xn,n=`${e.encode(2,t.encode(r.r))}${e.encode(2,t.encode(r.s))}`;return e.encode(48,n)}},vn=BigInt(0),tt=BigInt(1);BigInt(2);const kc=BigInt(3);BigInt(4);function $p(r){const e=Rp(r),{Fp:t}=e,n=So(e.n,e.nBitLength),s=e.toBytes||((g,d,w)=>{const S=d.toAffine();return cr(Uint8Array.from([4]),t.toBytes(S.x),t.toBytes(S.y))}),o=e.fromBytes||(g=>{const d=g.subarray(1),w=t.fromBytes(d.subarray(0,t.BYTES)),S=t.fromBytes(d.subarray(t.BYTES,2*t.BYTES));return{x:w,y:S}});function i(g){const{a:d,b:w}=e,S=t.sqr(g),y=t.mul(S,g);return t.add(t.add(y,t.mul(g,d)),w)}if(!t.eql(t.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return ko(g,tt,e.n)}function c(g){const{allowedPrivateKeyLengths:d,nByteLength:w,wrapPrivateKey:S,n:y}=e;if(d&&typeof g!="bigint"){if(ir(g)&&(g=ar(g)),typeof g!="string"||!d.includes(g.length))throw new Error("Invalid key");g=g.padStart(w*2,"0")}let I;try{I=typeof g=="bigint"?g:rr(Je("private key",g,w))}catch{throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof g}`)}return S&&(I=ze(I,y)),Ft("private key",I,tt,y),I}function u(g){if(!(g instanceof h))throw new Error("ProjectivePoint expected")}const l=bs((g,d)=>{const{px:w,py:S,pz:y}=g;if(t.eql(y,t.ONE))return{x:w,y:S};const I=g.is0();d==null&&(d=I?t.ONE:t.inv(y));const R=t.mul(w,d),T=t.mul(S,d),L=t.mul(y,d);if(I)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:R,y:T}}),f=bs(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:d,y:w}=g.toAffine();if(!t.isValid(d)||!t.isValid(w))throw new Error("bad point: x or y not FE");const S=t.sqr(w),y=i(d);if(!t.eql(S,y))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(d,w,S){if(this.px=d,this.py=w,this.pz=S,d==null||!t.isValid(d))throw new Error("x required");if(w==null||!t.isValid(w))throw new Error("y required");if(S==null||!t.isValid(S))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:w,y:S}=d||{};if(!d||!t.isValid(w)||!t.isValid(S))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const y=I=>t.eql(I,t.ZERO);return y(w)&&y(S)?h.ZERO:new h(w,S,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const w=t.invertBatch(d.map(S=>S.pz));return d.map((S,y)=>S.toAffine(w[y])).map(h.fromAffine)}static fromHex(d){const w=h.fromAffine(o(Je("pointHex",d)));return w.assertValidity(),w}static fromPrivateKey(d){return h.BASE.multiply(c(d))}static msm(d,w){return Iu(h,n,d,w)}_setWindowSize(d){b.setWindowSize(this,d)}assertValidity(){f(this)}hasEvenY(){const{y:d}=this.toAffine();if(t.isOdd)return!t.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){u(d);const{px:w,py:S,pz:y}=this,{px:I,py:R,pz:T}=d,L=t.eql(t.mul(w,T),t.mul(I,y)),P=t.eql(t.mul(S,T),t.mul(R,y));return L&&P}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a:d,b:w}=e,S=t.mul(w,kc),{px:y,py:I,pz:R}=this;let T=t.ZERO,L=t.ZERO,P=t.ZERO,U=t.mul(y,y),he=t.mul(I,I),Q=t.mul(R,R),V=t.mul(y,I);return V=t.add(V,V),P=t.mul(y,R),P=t.add(P,P),T=t.mul(d,P),L=t.mul(S,Q),L=t.add(T,L),T=t.sub(he,L),L=t.add(he,L),L=t.mul(T,L),T=t.mul(V,T),P=t.mul(S,P),Q=t.mul(d,Q),V=t.sub(U,Q),V=t.mul(d,V),V=t.add(V,P),P=t.add(U,U),U=t.add(P,U),U=t.add(U,Q),U=t.mul(U,V),L=t.add(L,U),Q=t.mul(I,R),Q=t.add(Q,Q),U=t.mul(Q,V),T=t.sub(T,U),P=t.mul(Q,he),P=t.add(P,P),P=t.add(P,P),new h(T,L,P)}add(d){u(d);const{px:w,py:S,pz:y}=this,{px:I,py:R,pz:T}=d;let L=t.ZERO,P=t.ZERO,U=t.ZERO;const he=e.a,Q=t.mul(e.b,kc);let V=t.mul(w,I),pe=t.mul(S,R),_=t.mul(y,T),$=t.add(w,S),k=t.add(I,R);$=t.mul($,k),k=t.add(V,pe),$=t.sub($,k),k=t.add(w,y);let m=t.add(I,T);return k=t.mul(k,m),m=t.add(V,_),k=t.sub(k,m),m=t.add(S,y),L=t.add(R,T),m=t.mul(m,L),L=t.add(pe,_),m=t.sub(m,L),U=t.mul(he,k),L=t.mul(Q,_),U=t.add(L,U),L=t.sub(pe,U),U=t.add(pe,U),P=t.mul(L,U),pe=t.add(V,V),pe=t.add(pe,V),_=t.mul(he,_),k=t.mul(Q,k),pe=t.add(pe,_),_=t.sub(V,_),_=t.mul(he,_),k=t.add(k,_),V=t.mul(pe,k),P=t.add(P,V),V=t.mul(m,k),L=t.mul($,L),L=t.sub(L,V),V=t.mul($,pe),U=t.mul(m,U),U=t.add(U,V),new h(L,P,U)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return b.wNAFCached(this,d,h.normalizeZ)}multiplyUnsafe(d){Ft("scalar",d,vn,e.n);const w=h.ZERO;if(d===vn)return w;if(d===tt)return this;const{endo:S}=e;if(!S)return b.unsafeLadder(this,d);let{k1neg:y,k1:I,k2neg:R,k2:T}=S.splitScalar(d),L=w,P=w,U=this;for(;I>vn||T>vn;)I&tt&&(L=L.add(U)),T&tt&&(P=P.add(U)),U=U.double(),I>>=tt,T>>=tt;return y&&(L=L.negate()),R&&(P=P.negate()),P=new h(t.mul(P.px,S.beta),P.py,P.pz),L.add(P)}multiply(d){const{endo:w,n:S}=e;Ft("scalar",d,tt,S);let y,I;if(w){const{k1neg:R,k1:T,k2neg:L,k2:P}=w.splitScalar(d);let{p:U,f:he}=this.wNAF(T),{p:Q,f:V}=this.wNAF(P);U=b.constTimeNegate(R,U),Q=b.constTimeNegate(L,Q),Q=new h(t.mul(Q.px,w.beta),Q.py,Q.pz),y=U.add(Q),I=he.add(V)}else{const{p:R,f:T}=this.wNAF(d);y=R,I=T}return h.normalizeZ([y,I])[0]}multiplyAndAddUnsafe(d,w,S){const y=h.BASE,I=(T,L)=>L===vn||L===tt||!T.equals(y)?T.multiplyUnsafe(L):T.multiply(L),R=I(this,w).add(I(d,S));return R.is0()?void 0:R}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:w}=e;if(d===tt)return!0;if(w)return w(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:w}=e;return d===tt?this:w?w(h,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return Rn("isCompressed",d),this.assertValidity(),s(h,this,d)}toHex(d=!0){return Rn("isCompressed",d),ar(this.toRawBytes(d))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const p=e.nBitLength,b=Eu(h,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:a}}function Pp(r){const e=oa(r);return jr(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Cp(r){const e=Pp(r),{Fp:t,n}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(_){return ze(_,n)}function a(_){return Ui(_,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:f}=$p({...e,toBytes(_,$,k){const m=$.toAffine(),x=t.toBytes(m.x),C=cr;return Rn("isCompressed",k),k?C(Uint8Array.from([$.hasEvenY()?2:3]),x):C(Uint8Array.from([4]),x,t.toBytes(m.y))},fromBytes(_){const $=_.length,k=_[0],m=_.subarray(1);if($===s&&(k===2||k===3)){const x=rr(m);if(!ko(x,tt,t.ORDER))throw new Error("Point is not on curve");const C=l(x);let D;try{D=t.sqrt(C)}catch(Z){const Y=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+Y)}const F=(D&tt)===tt;return(k&1)===1!==F&&(D=t.neg(D)),{x,y:D}}else if($===o&&k===4){const x=t.fromBytes(m.subarray(0,t.BYTES)),C=t.fromBytes(m.subarray(t.BYTES,2*t.BYTES));return{x,y:C}}else throw new Error(`Point of length ${$} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),h=_=>ar(Nr(_,e.nByteLength));function p(_){const $=n>>tt;return _>$}function b(_){return p(_)?i(-_):_}const g=(_,$,k)=>rr(_.slice($,k));class d{constructor($,k,m){this.r=$,this.s=k,this.recovery=m,this.assertValidity()}static fromCompact($){const k=e.nByteLength;return $=Je("compactSignature",$,k*2),new d(g($,0,k),g($,k,2*k))}static fromDER($){const{r:k,s:m}=xn.toSig(Je("DER",$));return new d(k,m)}assertValidity(){Ft("r",this.r,tt,n),Ft("s",this.s,tt,n)}addRecoveryBit($){return new d(this.r,this.s,$)}recoverPublicKey($){const{r:k,s:m,recovery:x}=this,C=T(Je("msgHash",$));if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");const D=x===2||x===3?k+e.n:k;if(D>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const F=x&1?"03":"02",G=c.fromHex(F+h(D)),Z=a(D),Y=i(-C*Z),re=i(m*Z),se=c.BASE.multiplyAndAddUnsafe(G,Y,re);if(!se)throw new Error("point at infinify");return se.assertValidity(),se}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return Ur(this.toDERHex())}toDERHex(){return xn.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ur(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const w={isValidPrivateKey(_){try{return u(_),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const _=xu(e.n);return nh(e.randomBytes(_),e.n)},precompute(_=8,$=c.BASE){return $._setWindowSize(_),$.multiply(BigInt(3)),$}};function S(_,$=!0){return c.fromPrivateKey(_).toRawBytes($)}function y(_){const $=ir(_),k=typeof _=="string",m=($||k)&&_.length;return $?m===s||m===o:k?m===2*s||m===2*o:_ instanceof c}function I(_,$,k=!0){if(y(_))throw new Error("first arg must be private key");if(!y($))throw new Error("second arg must be public key");return c.fromHex($).multiply(u(_)).toRawBytes(k)}const R=e.bits2int||function(_){const $=rr(_),k=_.length*8-e.nBitLength;return k>0?$>>BigInt(k):$},T=e.bits2int_modN||function(_){return i(R(_))},L=sa(e.nBitLength);function P(_){return Ft(`num < 2^${e.nBitLength}`,_,vn,L),Nr(_,e.nByteLength)}function U(_,$,k=he){if(["recovered","canonical"].some(be=>be in k))throw new Error("sign() legacy options not supported");const{hash:m,randomBytes:x}=e;let{lowS:C,prehash:D,extraEntropy:F}=k;C==null&&(C=!0),_=Je("msgHash",_),mc(k),D&&(_=Je("prehashed msgHash",m(_)));const G=T(_),Z=u($),Y=[P(Z),P(G)];if(F!=null&&F!==!1){const be=F===!0?x(t.BYTES):F;Y.push(Je("extraEntropy",be))}const re=cr(...Y),se=G;function ye(be){const me=R(be);if(!f(me))return;const ve=a(me),Ae=c.BASE.multiply(me).toAffine(),ge=i(Ae.x);if(ge===vn)return;const Fe=i(ve*i(se+ge*Z));if(Fe===vn)return;let qt=(Ae.x===ge?0:2)|Number(Ae.y&tt),jt=Fe;return C&&p(Fe)&&(jt=b(Fe),qt^=1),new d(ge,jt,qt)}return{seed:re,k2sig:ye}}const he={lowS:e.lowS,prehash:!1},Q={lowS:e.lowS,prehash:!1};function V(_,$,k=he){const{seed:m,k2sig:x}=U(_,$,k),C=e;return mu(C.hash.outputLen,C.nByteLength,C.hmac)(m,x)}c.BASE._setWindowSize(8);function pe(_,$,k,m=Q){var Ae;const x=_;if($=Je("msgHash",$),k=Je("publicKey",k),"strict"in m)throw new Error("options.strict was renamed to lowS");mc(m);const{lowS:C,prehash:D}=m;let F,G;try{if(typeof x=="string"||ir(x))try{F=d.fromDER(x)}catch(ge){if(!(ge instanceof xn.Err))throw ge;F=d.fromCompact(x)}else if(typeof x=="object"&&typeof x.r=="bigint"&&typeof x.s=="bigint"){const{r:ge,s:Fe}=x;F=new d(ge,Fe)}else throw new Error("PARSE");G=c.fromHex(k)}catch(ge){if(ge.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(C&&F.hasHighS())return!1;D&&($=e.hash($));const{r:Z,s:Y}=F,re=T($),se=a(Y),ye=i(re*se),be=i(Z*se),me=(Ae=c.BASE.multiplyAndAddUnsafe(G,ye,be))==null?void 0:Ae.toAffine();return me?i(me.x)===Z:!1}return{CURVE:e,getPublicKey:S,getSharedSecret:I,sign:V,verify:pe,ProjectivePoint:c,Signature:d,utils:w}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Op(r){return{hash:r,hmac:(e,...t)=>ol(r,e,cd(...t)),randomBytes:gu}}function Up(r,e){const t=n=>Cp({...r,...Op(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const il=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Sc=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Np=BigInt(1),Di=BigInt(2),xc=(r,e)=>(r+e/Di)/e;function zp(r){const e=il,t=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%e,l=u*u*r%e,f=je(l,t,e)*l%e,h=je(f,t,e)*l%e,p=je(h,Di,e)*u%e,b=je(p,s,e)*p%e,g=je(b,o,e)*b%e,d=je(g,a,e)*g%e,w=je(d,c,e)*d%e,S=je(w,a,e)*g%e,y=je(S,t,e)*l%e,I=je(y,i,e)*b%e,R=je(I,n,e)*u%e,T=je(R,Di,e);if(!Fi.eql(Fi.sqr(T),r))throw new Error("Cannot find square root");return T}const Fi=So(il,void 0,void 0,{sqrt:zp}),ma=Up({a:BigInt(0),b:BigInt(7),Fp:Fi,n:Sc,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Sc,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Np*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=xc(o*r,e),c=xc(-n*r,e);let u=ze(r-a*t-c*s,e),l=ze(-a*n-c*o,e);const f=u>i,h=l>i;if(f&&(u=e-u),h&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:f,k1:u,k2neg:h,k2:l}}}},Ni);BigInt(0);ma.ProjectivePoint;function Ec(r){try{return yh.ExtendedPoint.fromHex(r),!0}catch{return!1}}const Dp=r=>O.Buffer.isBuffer(r)?r:r instanceof Uint8Array?O.Buffer.from(r.buffer,r.byteOffset,r.byteLength):O.Buffer.from(r);let Fp=class{constructor(e){Object.assign(this,e)}encode(){return O.Buffer.from($u(Ys,this))}static decode(e){return Pu(Ys,this,e)}static decodeUnchecked(e){return Bu(Ys,this,e)}};const Ys=new Map;var al;const Mp=32,pi=32;function Hp(r){return r._bn!==void 0}let Ic=1,Te=class vr extends Fp{constructor(e){if(super({}),this._bn=void 0,Hp(e))this._bn=e._bn;else{if(typeof e=="string"){const t=yc.decode(e);if(t.length!=pi)throw new Error("Invalid public key input");this._bn=new ic(t)}else this._bn=new ic(e);if(this._bn.byteLength()>pi)throw new Error("Invalid public key input")}}static unique(){const e=new vr(Ic);return Ic+=1,new vr(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return yc.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(O.Buffer);if(e.length===pi)return e;const t=O.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=O.Buffer.concat([e.toBuffer(),O.Buffer.from(t),n.toBuffer()]),o=Ni(s);return new vr(o)}static createProgramAddressSync(e,t){let n=O.Buffer.alloc(0);e.forEach(function(o){if(o.length>Mp)throw new TypeError("Max seed length exceeded");n=O.Buffer.concat([n,Dp(o)])}),n=O.Buffer.concat([n,t.toBuffer(),O.Buffer.from("ProgramDerivedAddress")]);const s=Ni(n);if(Ec(s))throw new Error("Invalid seeds, address must fall off the curve");return new vr(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(O.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new vr(e);return Ec(t.toBytes())}};al=Te;Te.default=new al("11111111111111111111111111111111");Ys.set(Te,{kind:"struct",fields:[["_bn","u256"]]});new Te("BPFLoader1111111111111111111111111111111111");const Kp=64,Be=(r="publicKey")=>Dr(32,r),_r=(r="string")=>{const e=ie([oe("length"),oe("lengthPadding"),Dr(sr(oe(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:O.Buffer.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>oe().span+oe().span+O.Buffer.from(o,"utf8").length,s},Wp=(r="authorized")=>ie([Be("staker"),Be("withdrawer")],r),qp=(r="lockup")=>ie([Pt("unixTimestamp"),Pt("epoch"),Be("custodian")],r),jp=(r="voteInit")=>ie([Be("nodePubkey"),Be("authorizedVoter"),Be("authorizedWithdrawer"),Ze("commission")],r),Vp=(r="voteAuthorizeWithSeedArgs")=>ie([oe("voteAuthorizationType"),Be("currentAuthorityDerivedKeyOwnerPubkey"),_r("currentAuthorityDerivedKeySeed"),Be("newAuthorized")],r);O.Buffer.alloc(Kp).fill(0);new Te("SysvarC1ock11111111111111111111111111111111");new Te("SysvarEpochSchedu1e111111111111111111111111");new Te("Sysvar1nstructions1111111111111111111111111");new Te("SysvarRecentB1ockHashes11111111111111111111");new Te("SysvarRent111111111111111111111111111111111");new Te("SysvarRewards111111111111111111111111111111");new Te("SysvarS1otHashes111111111111111111111111111");new Te("SysvarS1otHistory11111111111111111111111111");new Te("SysvarStakeHistory1111111111111111111111111");const Gp=ut("lamportsPerSignature"),Yp=ie([oe("version"),oe("state"),Be("authorizedPubkey"),Be("nonce"),ie([Gp],"feeCalculator")]);Yp.span;const Zp=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},Xp=r=>e=>{const t=Dr(r,e),{encode:n,decode:s}=Zp(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return qh(O.Buffer.from(c))},o.encode=(i,a,c)=>{const u=Gh(i,r);return n(u,a,c)},o},Fr=Xp(8);Object.freeze({Create:{index:0,layout:ie([oe("instruction"),Pt("lamports"),Pt("space"),Be("programId")])},Assign:{index:1,layout:ie([oe("instruction"),Be("programId")])},Transfer:{index:2,layout:ie([oe("instruction"),Fr("lamports")])},CreateWithSeed:{index:3,layout:ie([oe("instruction"),Be("base"),_r("seed"),Pt("lamports"),Pt("space"),Be("programId")])},AdvanceNonceAccount:{index:4,layout:ie([oe("instruction")])},WithdrawNonceAccount:{index:5,layout:ie([oe("instruction"),Pt("lamports")])},InitializeNonceAccount:{index:6,layout:ie([oe("instruction"),Be("authorized")])},AuthorizeNonceAccount:{index:7,layout:ie([oe("instruction"),Be("authorized")])},Allocate:{index:8,layout:ie([oe("instruction"),Pt("space")])},AllocateWithSeed:{index:9,layout:ie([oe("instruction"),Be("base"),_r("seed"),Pt("space"),Be("programId")])},AssignWithSeed:{index:10,layout:ie([oe("instruction"),Be("base"),_r("seed"),Be("programId")])},TransferWithSeed:{index:11,layout:ie([oe("instruction"),Fr("lamports"),_r("seed"),Be("programId")])},UpgradeNonceAccount:{index:12,layout:ie([oe("instruction")])}});new Te("11111111111111111111111111111111");new Te("BPFLoader2111111111111111111111111111111111");ie([oe("typeIndex"),Fr("deactivationSlot"),ut("lastExtendedSlot"),Ze("lastExtendedStartIndex"),Ze(),tr(Be(),sr(Ze(),-1),"authority")]);const Ye=$s(ba(Te),H(),r=>new Te(r)),cl=wa([H(),Me("base64")]),ka=$s(ba(O.Buffer),cl,r=>O.Buffer.from(r[0],"base64"));function ul(r){return vt([N({jsonrpc:Me("2.0"),id:H(),result:r}),N({jsonrpc:Me("2.0"),id:H(),error:N({code:Yr(),message:H(),data:ae(np())})})])}const Jp=ul(Yr());function Ue(r){return $s(ul(r),Jp,e=>"error"in e?e:{...e,result:ws(e.result,r)})}function Wt(r){return Ue(N({context:N({slot:v()}),value:r}))}function _o(r){return N({context:N({slot:v()}),value:r})}const Qp=N({foundation:v(),foundationTerm:v(),initial:v(),taper:v(),terminal:v()});Ue(X(J(N({epoch:v(),effectiveSlot:v(),amount:v(),postBalance:v(),commission:ae(J(v()))}))));const e0=X(N({slot:v(),prioritizationFee:v()})),t0=N({total:v(),validator:v(),foundation:v(),epoch:v()}),n0=N({epoch:v(),slotIndex:v(),slotsInEpoch:v(),absoluteSlot:v(),blockHeight:ae(v()),transactionCount:ae(v())}),r0=N({slotsPerEpoch:v(),leaderScheduleSlotOffset:v(),warmup:fn(),firstNormalEpoch:v(),firstNormalSlot:v()}),s0=Ju(H(),X(v())),yr=J(vt([N({}),H()])),o0=N({err:yr}),i0=Me("receivedSignature");N({"solana-core":H(),"feature-set":ae(v())});const a0=N({program:H(),programId:Ye,parsed:Yr()}),c0=N({programId:Ye,accounts:X(Ye),data:H()});Wt(N({err:J(vt([N({}),H()])),logs:J(X(H())),accounts:ae(J(X(J(N({executable:fn(),owner:H(),lamports:v(),data:X(H()),rentEpoch:ae(v())}))))),unitsConsumed:ae(v()),returnData:ae(J(N({programId:H(),data:wa([H(),Me("base64")])}))),innerInstructions:ae(J(X(N({index:v(),instructions:X(vt([a0,c0]))}))))}));Wt(N({byIdentity:Ju(H(),X(v())),range:N({firstSlot:v(),lastSlot:v()})}));Ue(Qp);Ue(t0);Ue(e0);Ue(n0);Ue(r0);Ue(s0);Ue(v());Wt(N({total:v(),circulating:v(),nonCirculating:v(),nonCirculatingAccounts:X(Ye)}));const u0=N({amount:H(),uiAmount:J(v()),decimals:v(),uiAmountString:ae(H())});Wt(X(N({address:Ye,amount:H(),uiAmount:J(v()),decimals:v(),uiAmountString:ae(H())})));Wt(X(N({pubkey:Ye,account:N({executable:fn(),owner:Ye,lamports:v(),data:ka,rentEpoch:v()})})));const Mi=N({program:H(),parsed:Yr(),space:v()});Wt(X(N({pubkey:Ye,account:N({executable:fn(),owner:Ye,lamports:v(),data:Mi,rentEpoch:v()})})));Wt(X(N({lamports:v(),address:Ye})));const Sa=N({executable:fn(),owner:Ye,lamports:v(),data:ka,rentEpoch:v()});N({pubkey:Ye,account:Sa});const l0=$s(vt([ba(O.Buffer),Mi]),vt([cl,Mi]),r=>Array.isArray(r)?ws(r,ka):r),f0=N({executable:fn(),owner:Ye,lamports:v(),data:l0,rentEpoch:v()});N({pubkey:Ye,account:f0});N({state:vt([Me("active"),Me("inactive"),Me("activating"),Me("deactivating")]),active:v(),inactive:v()});Ue(X(N({signature:H(),slot:v(),err:yr,memo:J(H()),blockTime:ae(J(v()))})));Ue(X(N({signature:H(),slot:v(),err:yr,memo:J(H()),blockTime:ae(J(v()))})));N({subscription:v(),result:_o(Sa)});const d0=N({pubkey:Ye,account:Sa});N({subscription:v(),result:_o(d0)});const h0=N({parent:v(),slot:v(),root:v()});N({subscription:v(),result:h0});const p0=vt([N({type:vt([Me("firstShredReceived"),Me("completed"),Me("optimisticConfirmation"),Me("root")]),slot:v(),timestamp:v()}),N({type:Me("createdBank"),parent:v(),slot:v(),timestamp:v()}),N({type:Me("frozen"),slot:v(),timestamp:v(),stats:N({numTransactionEntries:v(),numSuccessfulTransactions:v(),numFailedTransactions:v(),maxTransactionsPerEntry:v()})}),N({type:Me("dead"),slot:v(),timestamp:v(),err:H()})]);N({subscription:v(),result:p0});N({subscription:v(),result:_o(vt([o0,i0]))});N({subscription:v(),result:v()});N({pubkey:H(),gossip:J(H()),tpu:J(H()),rpc:J(H()),version:J(H())});const vc=N({votePubkey:H(),nodePubkey:H(),activatedStake:v(),epochVoteAccount:fn(),epochCredits:X(wa([v(),v(),v()])),commission:v(),lastVote:v(),rootSlot:J(v())});Ue(N({current:X(vc),delinquent:X(vc)}));const g0=vt([Me("processed"),Me("confirmed"),Me("finalized")]),y0=N({slot:v(),confirmations:J(v()),err:yr,confirmationStatus:ae(g0)});Wt(X(J(y0)));Ue(v());const ll=N({accountKey:Ye,writableIndexes:X(v()),readonlyIndexes:X(v())}),xa=N({signatures:X(H()),message:N({accountKeys:X(H()),header:N({numRequiredSignatures:v(),numReadonlySignedAccounts:v(),numReadonlyUnsignedAccounts:v()}),instructions:X(N({accounts:X(v()),data:H(),programIdIndex:v()})),recentBlockhash:H(),addressTableLookups:ae(X(ll))})}),fl=N({pubkey:Ye,signer:fn(),writable:fn(),source:ae(vt([Me("transaction"),Me("lookupTable")]))}),dl=N({accountKeys:X(fl),signatures:X(H())}),hl=N({parsed:Yr(),program:H(),programId:Ye}),pl=N({accounts:X(Ye),data:H(),programId:Ye}),b0=vt([pl,hl]),w0=vt([N({parsed:Yr(),program:H(),programId:H()}),N({accounts:X(H()),data:H(),programId:H()})]),gl=$s(b0,w0,r=>"accounts"in r?ws(r,pl):ws(r,hl)),yl=N({signatures:X(H()),message:N({accountKeys:X(fl),instructions:X(gl),recentBlockhash:H(),addressTableLookups:ae(J(X(ll)))})}),io=N({accountIndex:v(),mint:H(),owner:ae(H()),uiTokenAmount:u0}),bl=N({writable:X(Ye),readonly:X(Ye)}),Ro=N({err:yr,fee:v(),innerInstructions:ae(J(X(N({index:v(),instructions:X(N({accounts:X(v()),data:H(),programIdIndex:v()}))})))),preBalances:X(v()),postBalances:X(v()),logMessages:ae(J(X(H()))),preTokenBalances:ae(J(X(io))),postTokenBalances:ae(J(X(io))),loadedAddresses:ae(bl),computeUnitsConsumed:ae(v())}),Ea=N({err:yr,fee:v(),innerInstructions:ae(J(X(N({index:v(),instructions:X(gl)})))),preBalances:X(v()),postBalances:X(v()),logMessages:ae(J(X(H()))),preTokenBalances:ae(J(X(io))),postTokenBalances:ae(J(X(io))),loadedAddresses:ae(bl),computeUnitsConsumed:ae(v())}),Zr=vt([Me(0),Me("legacy")]),br=N({pubkey:H(),lamports:v(),postBalance:J(v()),rewardType:J(H()),commission:ae(J(v()))});Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),transactions:X(N({transaction:xa,meta:J(Ro),version:ae(Zr)})),rewards:ae(X(br)),blockTime:J(v()),blockHeight:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),rewards:ae(X(br)),blockTime:J(v()),blockHeight:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),transactions:X(N({transaction:dl,meta:J(Ro),version:ae(Zr)})),rewards:ae(X(br)),blockTime:J(v()),blockHeight:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),transactions:X(N({transaction:yl,meta:J(Ea),version:ae(Zr)})),rewards:ae(X(br)),blockTime:J(v()),blockHeight:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),transactions:X(N({transaction:dl,meta:J(Ea),version:ae(Zr)})),rewards:ae(X(br)),blockTime:J(v()),blockHeight:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),rewards:ae(X(br)),blockTime:J(v()),blockHeight:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),transactions:X(N({transaction:xa,meta:J(Ro)})),rewards:ae(X(br)),blockTime:J(v())})));Ue(J(N({blockhash:H(),previousBlockhash:H(),parentSlot:v(),signatures:X(H()),blockTime:J(v())})));Ue(J(N({slot:v(),meta:J(Ro),blockTime:ae(J(v())),transaction:xa,version:ae(Zr)})));Ue(J(N({slot:v(),transaction:yl,meta:J(Ea),blockTime:ae(J(v())),version:ae(Zr)})));Wt(N({blockhash:H(),feeCalculator:N({lamportsPerSignature:v()})}));Wt(N({blockhash:H(),lastValidBlockHeight:v()}));Wt(fn());const m0=N({slot:v(),numTransactions:v(),numSlots:v(),samplePeriodSecs:v()});Ue(X(m0));Wt(J(N({feeCalculator:N({lamportsPerSignature:v()})})));Ue(H());Ue(H());const k0=N({err:yr,logs:X(H()),signature:H()});N({result:_o(k0),subscription:v()});Object.freeze({CreateLookupTable:{index:0,layout:ie([oe("instruction"),Fr("recentSlot"),Ze("bumpSeed")])},FreezeLookupTable:{index:1,layout:ie([oe("instruction")])},ExtendLookupTable:{index:2,layout:ie([oe("instruction"),Fr(),tr(Be(),sr(oe(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:ie([oe("instruction")])},CloseLookupTable:{index:4,layout:ie([oe("instruction")])}});new Te("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:ie([Ze("instruction"),oe("units"),oe("additionalFee")])},RequestHeapFrame:{index:1,layout:ie([Ze("instruction"),oe("bytes")])},SetComputeUnitLimit:{index:2,layout:ie([Ze("instruction"),oe("units")])},SetComputeUnitPrice:{index:3,layout:ie([Ze("instruction"),Fr("microLamports")])}});new Te("ComputeBudget111111111111111111111111111111");ie([Ze("numSignatures"),Ze("padding"),zt("signatureOffset"),zt("signatureInstructionIndex"),zt("publicKeyOffset"),zt("publicKeyInstructionIndex"),zt("messageDataOffset"),zt("messageDataSize"),zt("messageInstructionIndex")]);new Te("Ed25519SigVerify111111111111111111111111111");ma.utils.isValidPrivateKey;ma.getPublicKey;ie([Ze("numSignatures"),zt("signatureOffset"),Ze("signatureInstructionIndex"),zt("ethAddressOffset"),Ze("ethAddressInstructionIndex"),zt("messageDataOffset"),zt("messageDataSize"),Ze("messageInstructionIndex"),Dr(20,"ethAddress"),Dr(64,"signature"),Ze("recoveryId")]);new Te("KeccakSecp256k11111111111111111111111111111");var wl;new Te("StakeConfig11111111111111111111111111111111");let ml=class{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}};wl=ml;ml.default=new wl(0,0,Te.default);Object.freeze({Initialize:{index:0,layout:ie([oe("instruction"),Wp(),qp()])},Authorize:{index:1,layout:ie([oe("instruction"),Be("newAuthorized"),oe("stakeAuthorizationType")])},Delegate:{index:2,layout:ie([oe("instruction")])},Split:{index:3,layout:ie([oe("instruction"),Pt("lamports")])},Withdraw:{index:4,layout:ie([oe("instruction"),Pt("lamports")])},Deactivate:{index:5,layout:ie([oe("instruction")])},Merge:{index:7,layout:ie([oe("instruction")])},AuthorizeWithSeed:{index:8,layout:ie([oe("instruction"),Be("newAuthorized"),oe("stakeAuthorizationType"),_r("authoritySeed"),Be("authorityOwner")])}});new Te("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:ie([oe("instruction"),jp()])},Authorize:{index:1,layout:ie([oe("instruction"),Be("newAuthorized"),oe("voteAuthorizationType")])},Withdraw:{index:3,layout:ie([oe("instruction"),Pt("lamports")])},UpdateValidatorIdentity:{index:4,layout:ie([oe("instruction")])},AuthorizeWithSeed:{index:10,layout:ie([oe("instruction"),Vp()])}});new Te("Vote111111111111111111111111111111111111111");new Te("Va1idator1nfo111111111111111111111111111111");N({name:H(),website:ae(H()),details:ae(H()),iconUrl:ae(H()),keybaseUsername:ae(H())});new Te("Vote111111111111111111111111111111111111111");ie([Be("nodePubkey"),Be("authorizedWithdrawer"),Ze("commission"),ut(),tr(ie([ut("slot"),oe("confirmationCount")]),sr(oe(),-8),"votes"),Ze("rootSlotValid"),ut("rootSlot"),ut(),tr(ie([ut("epoch"),Be("authorizedVoter")]),sr(oe(),-8),"authorizedVoters"),ie([tr(ie([Be("authorizedPubkey"),ut("epochOfLastAuthorizedSwitch"),ut("targetEpoch")]),32,"buf"),ut("idx"),Ze("isEmpty")],"priorVoters"),ut(),tr(ie([ut("epoch"),ut("credits"),ut("prevCredits")]),sr(oe(),-8),"epochCredits"),ie([ut("slot"),ut("timestamp")],"lastTimestamp")]);var kl={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function o(c,u,l,f,h){if(typeof l!="function")throw new TypeError("The listener must be a function");var p=new s(l,f||c,h),b=t?t+u:u;return c._events[b]?c._events[b].fn?c._events[b]=[c._events[b],p]:c._events[b].push(p):(c._events[b]=p,c._eventsCount++),c}function i(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,f;if(this._eventsCount===0)return u;for(f in l=this._events)e.call(l,f)&&u.push(t?f.slice(1):f);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,f=this._events[l];if(!f)return[];if(f.fn)return[f.fn];for(var h=0,p=f.length,b=new Array(p);h<p;h++)b[h]=f[h].fn;return b},a.prototype.listenerCount=function(u){var l=t?t+u:u,f=this._events[l];return f?f.fn?1:f.length:0},a.prototype.emit=function(u,l,f,h,p,b){var g=t?t+u:u;if(!this._events[g])return!1;var d=this._events[g],w=arguments.length,S,y;if(d.fn){switch(d.once&&this.removeListener(u,d.fn,void 0,!0),w){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,l),!0;case 3:return d.fn.call(d.context,l,f),!0;case 4:return d.fn.call(d.context,l,f,h),!0;case 5:return d.fn.call(d.context,l,f,h,p),!0;case 6:return d.fn.call(d.context,l,f,h,p,b),!0}for(y=1,S=new Array(w-1);y<w;y++)S[y-1]=arguments[y];d.fn.apply(d.context,S)}else{var I=d.length,R;for(y=0;y<I;y++)switch(d[y].once&&this.removeListener(u,d[y].fn,void 0,!0),w){case 1:d[y].fn.call(d[y].context);break;case 2:d[y].fn.call(d[y].context,l);break;case 3:d[y].fn.call(d[y].context,l,f);break;case 4:d[y].fn.call(d[y].context,l,f,h);break;default:if(!S)for(R=1,S=new Array(w-1);R<w;R++)S[R-1]=arguments[R];d[y].fn.apply(d[y].context,S)}}return!0},a.prototype.on=function(u,l,f){return o(this,u,l,f,!1)},a.prototype.once=function(u,l,f){return o(this,u,l,f,!0)},a.prototype.removeListener=function(u,l,f,h){var p=t?t+u:u;if(!this._events[p])return this;if(!l)return i(this,p),this;var b=this._events[p];if(b.fn)b.fn===l&&(!h||b.once)&&(!f||b.context===f)&&i(this,p);else{for(var g=0,d=[],w=b.length;g<w;g++)(b[g].fn!==l||h&&!b[g].once||f&&b[g].context!==f)&&d.push(b[g]);d.length?this._events[p]=d.length===1?d[0]:d:i(this,p)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&i(this,l)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(kl);var S0=kl.exports;const x0=As(S0);class en extends Error{constructor(e,t){super(e),this.error=t}}class E0 extends en{constructor(){super(...arguments),this.name="WalletNotReadyError"}}class I0 extends en{constructor(){super(...arguments),this.name="WalletConnectionError"}}class v0 extends en{constructor(){super(...arguments),this.name="WalletDisconnectedError"}}class A0 extends en{constructor(){super(...arguments),this.name="WalletDisconnectionError"}}class B0 extends en{constructor(){super(...arguments),this.name="WalletAccountError"}}class Ac extends en{constructor(){super(...arguments),this.name="WalletPublicKeyError"}}class hs extends en{constructor(){super(...arguments),this.name="WalletNotConnectedError"}}class ps extends en{constructor(){super(...arguments),this.name="WalletSendTransactionError"}}class Rr extends en{constructor(){super(...arguments),this.name="WalletSignTransactionError"}}class _0 extends en{constructor(){super(...arguments),this.name="WalletSignMessageError"}}var sn;(function(r){r.Installed="Installed",r.NotDetected="NotDetected",r.Loadable="Loadable",r.Unsupported="Unsupported"})(sn||(sn={}));class R0 extends x0{get connected(){return!!this.publicKey}async autoConnect(){await this.connect()}async prepareTransaction(e,t,n={}){const s=this.publicKey;if(!s)throw new hs;return e.feePayer=e.feePayer||s,e.recentBlockhash=e.recentBlockhash||(await t.getLatestBlockhash({commitment:n.preflightCommitment,minContextSlot:n.minContextSlot})).blockhash,e}}function L0(r){if(typeof window>"u"||typeof document>"u")return;const e=[];function t(){if(r())for(const o of e)o()}const n=setInterval(t,1e3);e.push(()=>clearInterval(n)),document.readyState==="loading"&&(document.addEventListener("DOMContentLoaded",t,{once:!0}),e.push(()=>document.removeEventListener("DOMContentLoaded",t))),document.readyState!=="complete"&&(window.addEventListener("load",t,{once:!0}),e.push(()=>window.removeEventListener("load",t))),t()}function T0(){if(!navigator)return!1;const r=navigator.userAgent.toLowerCase(),e=r.includes("iphone")||r.includes("ipad"),t=r.includes("safari");return e&&t}function Hi(r){return"version"in r}class $0 extends R0{async sendTransaction(e,t,n={}){let s=!0;try{if(Hi(e)){if(!this.supportedTransactionVersions)throw new ps("Sending versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(e.version))throw new ps(`Sending transaction version ${e.version} isn't supported by this wallet`);try{e=await this.signTransaction(e);const o=e.serialize();return await t.sendRawTransaction(o,n)}catch(o){throw o instanceof Rr?(s=!1,o):new ps(o==null?void 0:o.message,o)}}else try{const{signers:o,...i}=n;e=await this.prepareTransaction(e,t,i),o!=null&&o.length&&e.partialSign(...o),e=await this.signTransaction(e);const a=e.serialize();return await t.sendRawTransaction(a,i)}catch(o){throw o instanceof Rr?(s=!1,o):new ps(o==null?void 0:o.message,o)}}catch(o){throw s&&this.emit("error",o),o}}async signAllTransactions(e){for(const n of e)if(Hi(n)){if(!this.supportedTransactionVersions)throw new Rr("Signing versioned transactions isn't supported by this wallet");if(!this.supportedTransactionVersions.has(n.version))throw new Rr(`Signing transaction version ${n.version} isn't supported by this wallet`)}const t=[];for(const n of e)t.push(await this.signTransaction(n));return t}}class P0 extends $0{}const C0="Phantom";class e2 extends P0{constructor(e={}){super(),this.name=C0,this.url="https://phantom.app",this.icon="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==",this.supportedTransactionVersions=new Set(["legacy",0]),this._readyState=typeof window>"u"||typeof document>"u"?sn.Unsupported:sn.NotDetected,this._disconnected=()=>{const t=this._wallet;t&&(t.off("disconnect",this._disconnected),t.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null,this.emit("error",new v0),this.emit("disconnect"))},this._accountChanged=t=>{const n=this._publicKey;if(n){try{t=new Te(t.toBytes())}catch(s){this.emit("error",new Ac(s==null?void 0:s.message,s));return}n.equals(t)||(this._publicKey=t,this.emit("connect",t))}},this._connecting=!1,this._wallet=null,this._publicKey=null,this._readyState!==sn.Unsupported&&(T0()?(this._readyState=sn.Loadable,this.emit("readyStateChange",this._readyState)):L0(()=>{var t,n,s;return(n=(t=window.phantom)==null?void 0:t.solana)!=null&&n.isPhantom||(s=window.solana)!=null&&s.isPhantom?(this._readyState=sn.Installed,this.emit("readyStateChange",this._readyState),!0):!1}))}get publicKey(){return this._publicKey}get connecting(){return this._connecting}get readyState(){return this._readyState}async autoConnect(){this.readyState===sn.Installed&&await this.connect()}async connect(){var e;try{if(this.connected||this.connecting)return;if(this.readyState===sn.Loadable){const s=encodeURIComponent(window.location.href),o=encodeURIComponent(window.location.origin);window.location.href=`https://phantom.app/ul/browse/${s}?ref=${o}`;return}if(this.readyState!==sn.Installed)throw new E0;this._connecting=!0;const t=((e=window.phantom)==null?void 0:e.solana)||window.solana;if(!t.isConnected)try{await t.connect()}catch(s){throw new I0(s==null?void 0:s.message,s)}if(!t.publicKey)throw new B0;let n;try{n=new Te(t.publicKey.toBytes())}catch(s){throw new Ac(s==null?void 0:s.message,s)}t.on("disconnect",this._disconnected),t.on("accountChanged",this._accountChanged),this._wallet=t,this._publicKey=n,this.emit("connect",n)}catch(t){throw this.emit("error",t),t}finally{this._connecting=!1}}async disconnect(){const e=this._wallet;if(e){e.off("disconnect",this._disconnected),e.off("accountChanged",this._accountChanged),this._wallet=null,this._publicKey=null;try{await e.disconnect()}catch(t){this.emit("error",new A0(t==null?void 0:t.message,t))}}this.emit("disconnect")}async sendTransaction(e,t,n={}){try{const s=this._wallet;if(!s)throw new hs;try{const{signers:o,...i}=n;Hi(e)?o!=null&&o.length&&e.sign(o):(e=await this.prepareTransaction(e,t,i),o!=null&&o.length&&e.partialSign(...o)),i.preflightCommitment=i.preflightCommitment||t.commitment;const{signature:a}=await s.signAndSendTransaction(e,i);return a}catch(o){throw o instanceof en?o:new ps(o==null?void 0:o.message,o)}}catch(s){throw this.emit("error",s),s}}async signTransaction(e){try{const t=this._wallet;if(!t)throw new hs;try{return await t.signTransaction(e)||e}catch(n){throw new Rr(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signAllTransactions(e){try{const t=this._wallet;if(!t)throw new hs;try{return await t.signAllTransactions(e)||e}catch(n){throw new Rr(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}async signMessage(e){try{const t=this._wallet;if(!t)throw new hs;try{const{signature:n}=await t.signMessage(e);return n}catch(n){throw new _0(n==null?void 0:n.message,n)}}catch(t){throw this.emit("error",t),t}}}function Bc(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function O0(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Lo(r,...e){if(!O0(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function U0(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Bc(r.outputLen),Bc(r.blockLen)}function ao(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function N0(r,e){Lo(r);const t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const Er=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gi=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),nn=(r,e)=>r<<32-e|r>>>e;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function z0(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Ia(r){return typeof r=="string"&&(r=z0(r)),Lo(r),r}function D0(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];Lo(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}let Sl=class{clone(){return this._cloneInto()}};function xl(r){const e=n=>r().update(Ia(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function El(r=32){if(Er&&typeof Er.getRandomValues=="function")return Er.getRandomValues(new Uint8Array(r));if(Er&&typeof Er.randomBytes=="function")return Er.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function F0(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}const M0=(r,e,t)=>r&e^~r&t,H0=(r,e,t)=>r&e^r&t^e&t;let Il=class extends Sl{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=gi(this.buffer)}update(e){ao(this);const{view:t,buffer:n,blockLen:s}=this;e=Ia(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=gi(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ao(this),N0(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let f=i;f<s;f++)t[f]=0;F0(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=gi(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)a.setUint32(4*f,l[f],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}};const Ks=BigInt(2**32-1),Ki=BigInt(32);function vl(r,e=!1){return e?{h:Number(r&Ks),l:Number(r>>Ki&Ks)}:{h:Number(r>>Ki&Ks)|0,l:Number(r&Ks)|0}}function K0(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=vl(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const W0=(r,e)=>BigInt(r>>>0)<<Ki|BigInt(e>>>0),q0=(r,e,t)=>r>>>t,j0=(r,e,t)=>r<<32-t|e>>>t,V0=(r,e,t)=>r>>>t|e<<32-t,G0=(r,e,t)=>r<<32-t|e>>>t,Y0=(r,e,t)=>r<<64-t|e>>>t-32,Z0=(r,e,t)=>r>>>t-32|e<<64-t,X0=(r,e)=>e,J0=(r,e)=>r,Q0=(r,e,t)=>r<<t|e>>>32-t,e1=(r,e,t)=>e<<t|r>>>32-t,t1=(r,e,t)=>e<<t-32|r>>>64-t,n1=(r,e,t)=>r<<t-32|e>>>64-t;function r1(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const s1=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),o1=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,i1=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),a1=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,c1=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),u1=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,le={fromBig:vl,split:K0,toBig:W0,shrSH:q0,shrSL:j0,rotrSH:V0,rotrSL:G0,rotrBH:Y0,rotrBL:Z0,rotr32H:X0,rotr32L:J0,rotlSH:Q0,rotlSL:e1,rotlBH:t1,rotlBL:n1,add:r1,add3L:s1,add3H:o1,add4L:i1,add4H:a1,add5H:u1,add5L:c1},[l1,f1]=le.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),On=new Uint32Array(80),Un=new Uint32Array(80);class d1 extends Il{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:f,Fl:h,Gh:p,Gl:b,Hh:g,Hl:d}=this;return[e,t,n,s,o,i,a,c,u,l,f,h,p,b,g,d]}set(e,t,n,s,o,i,a,c,u,l,f,h,p,b,g,d){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=f|0,this.Fl=h|0,this.Gh=p|0,this.Gl=b|0,this.Hh=g|0,this.Hl=d|0}process(e,t){for(let y=0;y<16;y++,t+=4)On[y]=e.getUint32(t),Un[y]=e.getUint32(t+=4);for(let y=16;y<80;y++){const I=On[y-15]|0,R=Un[y-15]|0,T=le.rotrSH(I,R,1)^le.rotrSH(I,R,8)^le.shrSH(I,R,7),L=le.rotrSL(I,R,1)^le.rotrSL(I,R,8)^le.shrSL(I,R,7),P=On[y-2]|0,U=Un[y-2]|0,he=le.rotrSH(P,U,19)^le.rotrBH(P,U,61)^le.shrSH(P,U,6),Q=le.rotrSL(P,U,19)^le.rotrBL(P,U,61)^le.shrSL(P,U,6),V=le.add4L(L,Q,Un[y-7],Un[y-16]),pe=le.add4H(V,T,he,On[y-7],On[y-16]);On[y]=pe|0,Un[y]=V|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:f,El:h,Fh:p,Fl:b,Gh:g,Gl:d,Hh:w,Hl:S}=this;for(let y=0;y<80;y++){const I=le.rotrSH(f,h,14)^le.rotrSH(f,h,18)^le.rotrBH(f,h,41),R=le.rotrSL(f,h,14)^le.rotrSL(f,h,18)^le.rotrBL(f,h,41),T=f&p^~f&g,L=h&b^~h&d,P=le.add5L(S,R,L,f1[y],Un[y]),U=le.add5H(P,w,I,T,l1[y],On[y]),he=P|0,Q=le.rotrSH(n,s,28)^le.rotrBH(n,s,34)^le.rotrBH(n,s,39),V=le.rotrSL(n,s,28)^le.rotrBL(n,s,34)^le.rotrBL(n,s,39),pe=n&o^n&a^o&a,_=s&i^s&c^i&c;w=g|0,S=d|0,g=p|0,d=b|0,p=f|0,b=h|0,{h:f,l:h}=le.add(u|0,l|0,U|0,he|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const $=le.add3L(he,V,_);n=le.add3H($,U,Q,pe),s=$|0}({h:n,l:s}=le.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=le.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=le.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=le.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:f,l:h}=le.add(this.Eh|0,this.El|0,f|0,h|0),{h:p,l:b}=le.add(this.Fh|0,this.Fl|0,p|0,b|0),{h:g,l:d}=le.add(this.Gh|0,this.Gl|0,g|0,d|0),{h:w,l:S}=le.add(this.Hh|0,this.Hl|0,w|0,S|0),this.set(n,s,o,i,a,c,u,l,f,h,p,b,g,d,w,S)}roundClean(){On.fill(0),Un.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const h1=xl(()=>new d1);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const va=BigInt(0),To=BigInt(1),p1=BigInt(2);function ur(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Ps(r){if(!ur(r))throw new Error("Uint8Array expected")}function Ln(r,e){if(typeof e!="boolean")throw new Error(`${r} must be valid boolean, got "${e}".`)}const g1=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function lr(r){Ps(r);let e="";for(let t=0;t<r.length;t++)e+=g1[r[t]];return e}function Lr(r){const e=r.toString(16);return e.length&1?`0${e}`:e}function Aa(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}const kn={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function _c(r){if(r>=kn._0&&r<=kn._9)return r-kn._0;if(r>=kn._A&&r<=kn._F)return r-(kn._A-10);if(r>=kn._a&&r<=kn._f)return r-(kn._a-10)}function Mr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const i=_c(r.charCodeAt(o)),a=_c(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function or(r){return Aa(lr(r))}function Pr(r){return Ps(r),Aa(lr(Uint8Array.from(r).reverse()))}function Hr(r,e){return Mr(r.toString(16).padStart(e*2,"0"))}function ms(r,e){return Hr(r,e).reverse()}function y1(r){return Mr(Lr(r))}function Qe(r,e,t){let n;if(typeof e=="string")try{n=Mr(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(ur(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(`${r} expected ${t} bytes, got ${s}`);return n}function fr(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];Ps(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}function b1(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function w1(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}const yi=r=>typeof r=="bigint"&&va<=r;function $o(r,e,t){return yi(r)&&yi(e)&&yi(t)&&e<=r&&r<t}function Mt(r,e,t,n){if(!$o(e,t,n))throw new Error(`expected valid ${r}: ${t} <= n < ${n}, got ${typeof e} ${e}`)}function Al(r){let e;for(e=0;r>va;r>>=To,e+=1);return e}function m1(r,e){return r>>BigInt(e)&To}function k1(r,e,t){return r|(t?To:va)<<BigInt(e)}const Ba=r=>(p1<<BigInt(r-1))-To,bi=r=>new Uint8Array(r),Rc=r=>Uint8Array.from(r);function Bl(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=bi(r),s=bi(r),o=0;const i=()=>{n.fill(1),s.fill(0),o=0},a=(...f)=>t(s,n,...f),c=(f=bi())=>{s=a(Rc([0]),f),n=a(),f.length!==0&&(s=a(Rc([1]),f),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const h=[];for(;f<e;){n=a();const p=n.slice();h.push(p),f+=n.length}return fr(...h)};return(f,h)=>{i(),c(f);let p;for(;!(p=h(u()));)c();return i(),p}}const S1={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ur(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Xr(r,e,t={}){const n=(s,o,i)=>{const a=S1[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(e))n(s,o,!1);for(const[s,o]of Object.entries(t))n(s,o,!0);return r}const x1=()=>{throw new Error("not implemented")};function ks(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const o=r(t,...n);return e.set(t,o),o}}const E1=Object.freeze(Object.defineProperty({__proto__:null,aInRange:Mt,abool:Ln,abytes:Ps,bitGet:m1,bitLen:Al,bitMask:Ba,bitSet:k1,bytesToHex:lr,bytesToNumberBE:or,bytesToNumberLE:Pr,concatBytes:fr,createHmacDrbg:Bl,ensureBytes:Qe,equalBytes:b1,hexToBytes:Mr,hexToNumber:Aa,inRange:$o,isBytes:ur,memoized:ks,notImplemented:x1,numberToBytesBE:Hr,numberToBytesLE:ms,numberToHexUnpadded:Lr,numberToVarBytesBE:y1,utf8ToBytes:w1,validateObject:Xr},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const it=BigInt(0),We=BigInt(1),Xn=BigInt(2),I1=BigInt(3),Wi=BigInt(4),Lc=BigInt(5),Tc=BigInt(8);BigInt(9);BigInt(16);function De(r,e){const t=r%e;return t>=it?t:e+t}function v1(r,e,t){if(t<=it||e<it)throw new Error("Expected power/modulo > 0");if(t===We)return it;let n=We;for(;e>it;)e&We&&(n=n*r%t),r=r*r%t,e>>=We;return n}function Ve(r,e,t){let n=r;for(;e-- >it;)n*=n,n%=t;return n}function qi(r,e){if(r===it||e<=it)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=De(r,e),n=e,s=it,o=We;for(;t!==it;){const a=n/t,c=n%t,u=s-o*a;n=t,t=c,s=o,o=u}if(n!==We)throw new Error("invert: does not exist");return De(s,e)}function A1(r){const e=(r-We)/Xn;let t,n,s;for(t=r-We,n=0;t%Xn===it;t/=Xn,n++);for(s=Xn;s<r&&v1(s,e,r)!==r-We;s++);if(n===1){const i=(r+We)/Wi;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+We)/Xn;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),t),f=a.pow(c,o),h=a.pow(c,t);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let p=1;for(let g=a.sqr(h);p<u&&!a.eql(g,a.ONE);p++)g=a.sqr(g);const b=a.pow(l,We<<BigInt(u-p-1));l=a.sqr(b),f=a.mul(f,b),h=a.mul(h,l),u=p}return f}}function B1(r){if(r%Wi===I1){const e=(r+We)/Wi;return function(n,s){const o=n.pow(s,e);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Tc===Lc){const e=(r-Lc)/Tc;return function(n,s){const o=n.mul(s,Xn),i=n.pow(o,e),a=n.mul(s,i),c=n.mul(n.mul(a,Xn),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return A1(r)}const _1=(r,e)=>(De(r,e)&We)===We,R1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function L1(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=R1.reduce((n,s)=>(n[s]="function",n),e);return Xr(r,t)}function T1(r,e,t){if(t<it)throw new Error("Expected power > 0");if(t===it)return r.ONE;if(t===We)return e;let n=r.ONE,s=e;for(;t>it;)t&We&&(n=r.mul(n,s)),s=r.sqr(s),t>>=We;return n}function $1(r,e){const t=new Array(e.length),n=e.reduce((o,i,a)=>r.is0(i)?o:(t[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return e.reduceRight((o,i,a)=>r.is0(i)?o:(t[a]=r.mul(o,t[a]),r.mul(o,i)),s),t}function _l(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Po(r,e,t=!1,n={}){if(r<=it)throw new Error(`Expected Field ORDER > 0, got ${r}`);const{nBitLength:s,nByteLength:o}=_l(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=B1(r),a=Object.freeze({ORDER:r,BITS:s,BYTES:o,MASK:Ba(s),ZERO:it,ONE:We,create:c=>De(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return it<=c&&c<r},is0:c=>c===it,isOdd:c=>(c&We)===We,neg:c=>De(-c,r),eql:(c,u)=>c===u,sqr:c=>De(c*c,r),add:(c,u)=>De(c+u,r),sub:(c,u)=>De(c-u,r),mul:(c,u)=>De(c*u,r),pow:(c,u)=>T1(a,c,u),div:(c,u)=>De(c*qi(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>qi(c,r),sqrt:n.sqrt||(c=>i(a,c)),invertBatch:c=>$1(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?ms(c,o):Hr(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?Pr(c):or(c)}});return Object.freeze(a)}function Rl(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Ll(r){const e=Rl(r);return e+Math.ceil(e/2)}function P1(r,e,t=!1){const n=r.length,s=Rl(e),o=Ll(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const i=t?or(r):Pr(r),a=De(i,e-We)+We;return t?ms(a,s):Hr(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C1=BigInt(0),wi=BigInt(1),mi=new WeakMap,$c=new WeakMap;function Tl(r,e){const t=(o,i)=>{const a=i.negate();return o?a:i},n=o=>{if(!Number.isSafeInteger(o)||o<=0||o>e)throw new Error(`Wrong window size=${o}, should be [1..${e}]`)},s=o=>{n(o);const i=Math.ceil(e/o)+1,a=2**(o-1);return{windows:i,windowSize:a}};return{constTimeNegate:t,unsafeLadder(o,i){let a=r.ZERO,c=o;for(;i>C1;)i&wi&&(a=a.add(c)),c=c.double(),i>>=wi;return a},precomputeWindow(o,i){const{windows:a,windowSize:c}=s(i),u=[];let l=o,f=l;for(let h=0;h<a;h++){f=l,u.push(f);for(let p=1;p<c;p++)f=f.add(l),u.push(f);l=f.double()}return u},wNAF(o,i,a){const{windows:c,windowSize:u}=s(o);let l=r.ZERO,f=r.BASE;const h=BigInt(2**o-1),p=2**o,b=BigInt(o);for(let g=0;g<c;g++){const d=g*u;let w=Number(a&h);a>>=b,w>u&&(w-=p,a+=wi);const S=d,y=d+Math.abs(w)-1,I=g%2!==0,R=w<0;w===0?f=f.add(t(I,i[S])):l=l.add(t(R,i[y]))}return{p:l,f}},wNAFCached(o,i,a){const c=$c.get(o)||1;let u=mi.get(o);return u||(u=this.precomputeWindow(o,c),c!==1&&mi.set(o,a(u))),this.wNAF(c,u,i)},setWindowSize(o,i){n(i),$c.set(o,i),mi.delete(o)}}}function $l(r,e,t,n){if(!Array.isArray(t)||!Array.isArray(n)||n.length!==t.length)throw new Error("arrays of points and scalars must have equal length");n.forEach((l,f)=>{if(!e.isValid(l))throw new Error(`wrong scalar at index ${f}`)}),t.forEach((l,f)=>{if(!(l instanceof r))throw new Error(`wrong point at index ${f}`)});const s=Al(BigInt(t.length)),o=s>12?s-3:s>4?s-2:s?2:1,i=(1<<o)-1,a=new Array(i+1).fill(r.ZERO),c=Math.floor((e.BITS-1)/o)*o;let u=r.ZERO;for(let l=c;l>=0;l-=o){a.fill(r.ZERO);for(let h=0;h<n.length;h++){const p=n[h],b=Number(p>>BigInt(l)&BigInt(i));a[b]=a[b].add(t[h])}let f=r.ZERO;for(let h=a.length-1,p=r.ZERO;h>0;h--)p=p.add(a[h]),f=f.add(p);if(u=u.add(f),l!==0)for(let h=0;h<o;h++)u=u.double()}return u}function _a(r){return L1(r.Fp),Xr(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._l(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Gt=BigInt(0),_t=BigInt(1),Ws=BigInt(2),O1=BigInt(8),U1={zip215:!0};function N1(r){const e=_a(r);return Xr(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function z1(r){const e=N1(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=Ws<<BigInt(a*8)-_t,l=t.create,f=Po(e.n,e.nBitLength),h=e.uvRatio||((k,m)=>{try{return{isValid:!0,value:t.sqrt(k*t.inv(m))}}catch{return{isValid:!1,value:Gt}}}),p=e.adjustScalarBytes||(k=>k),b=e.domain||((k,m,x)=>{if(Ln("phflag",x),m.length||x)throw new Error("Contexts/pre-hash are not supported");return k});function g(k,m){Mt("coordinate "+k,m,Gt,u)}function d(k){if(!(k instanceof y))throw new Error("ExtendedPoint expected")}const w=ks((k,m)=>{const{ex:x,ey:C,ez:D}=k,F=k.is0();m==null&&(m=F?O1:t.inv(D));const G=l(x*m),Z=l(C*m),Y=l(D*m);if(F)return{x:Gt,y:_t};if(Y!==_t)throw new Error("invZ was invalid");return{x:G,y:Z}}),S=ks(k=>{const{a:m,d:x}=e;if(k.is0())throw new Error("bad point: ZERO");const{ex:C,ey:D,ez:F,et:G}=k,Z=l(C*C),Y=l(D*D),re=l(F*F),se=l(re*re),ye=l(Z*m),be=l(re*l(ye+Y)),me=l(se+l(x*l(Z*Y)));if(be!==me)throw new Error("bad point: equation left != right (1)");const ve=l(C*D),Ae=l(F*G);if(ve!==Ae)throw new Error("bad point: equation left != right (2)");return!0});class y{constructor(m,x,C,D){this.ex=m,this.ey=x,this.ez=C,this.et=D,g("x",m),g("y",x),g("z",C),g("t",D),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof y)throw new Error("extended point not allowed");const{x,y:C}=m||{};return g("x",x),g("y",C),new y(x,C,_t,l(x*C))}static normalizeZ(m){const x=t.invertBatch(m.map(C=>C.ez));return m.map((C,D)=>C.toAffine(x[D])).map(y.fromAffine)}static msm(m,x){return $l(y,f,m,x)}_setWindowSize(m){T.setWindowSize(this,m)}assertValidity(){S(this)}equals(m){d(m);const{ex:x,ey:C,ez:D}=this,{ex:F,ey:G,ez:Z}=m,Y=l(x*Z),re=l(F*D),se=l(C*Z),ye=l(G*D);return Y===re&&se===ye}is0(){return this.equals(y.ZERO)}negate(){return new y(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:m}=e,{ex:x,ey:C,ez:D}=this,F=l(x*x),G=l(C*C),Z=l(Ws*l(D*D)),Y=l(m*F),re=x+C,se=l(l(re*re)-F-G),ye=Y+G,be=ye-Z,me=Y-G,ve=l(se*be),Ae=l(ye*me),ge=l(se*me),Fe=l(be*ye);return new y(ve,Ae,Fe,ge)}add(m){d(m);const{a:x,d:C}=e,{ex:D,ey:F,ez:G,et:Z}=this,{ex:Y,ey:re,ez:se,et:ye}=m;if(x===BigInt(-1)){const ss=l((F-D)*(re+Y)),os=l((F+D)*(re-Y)),Vn=l(os-ss);if(Vn===Gt)return this.double();const is=l(G*Ws*ye),as=l(Z*Ws*se),cs=as+is,us=os+ss,ls=as-is,Jo=l(cs*Vn),Qo=l(us*ls),ei=l(cs*ls),ti=l(Vn*us);return new y(Jo,Qo,ti,ei)}const be=l(D*Y),me=l(F*re),ve=l(Z*C*ye),Ae=l(G*se),ge=l((D+F)*(Y+re)-be-me),Fe=Ae-ve,qt=Ae+ve,jt=l(me-x*be),Go=l(ge*Fe),Yo=l(qt*jt),Zo=l(ge*jt),Xo=l(Fe*qt);return new y(Go,Yo,Xo,Zo)}subtract(m){return this.add(m.negate())}wNAF(m){return T.wNAFCached(this,m,y.normalizeZ)}multiply(m){const x=m;Mt("scalar",x,_t,n);const{p:C,f:D}=this.wNAF(x);return y.normalizeZ([C,D])[0]}multiplyUnsafe(m){const x=m;return Mt("scalar",x,Gt,n),x===Gt?R:this.equals(R)||x===_t?this:this.equals(I)?this.wNAF(x).p:T.unsafeLadder(this,x)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return T.unsafeLadder(this,n).is0()}toAffine(m){return w(this,m)}clearCofactor(){const{h:m}=e;return m===_t?this:this.multiplyUnsafe(m)}static fromHex(m,x=!1){const{d:C,a:D}=e,F=t.BYTES;m=Qe("pointHex",m,F),Ln("zip215",x);const G=m.slice(),Z=m[F-1];G[F-1]=Z&-129;const Y=Pr(G),re=x?u:t.ORDER;Mt("pointHex.y",Y,Gt,re);const se=l(Y*Y),ye=l(se-_t),be=l(C*se-D);let{isValid:me,value:ve}=h(ye,be);if(!me)throw new Error("Point.fromHex: invalid y coordinate");const Ae=(ve&_t)===_t,ge=(Z&128)!==0;if(!x&&ve===Gt&&ge)throw new Error("Point.fromHex: x=0 and x_0=1");return ge!==Ae&&(ve=l(-ve)),y.fromAffine({x:ve,y:Y})}static fromPrivateKey(m){return U(m).point}toRawBytes(){const{x:m,y:x}=this.toAffine(),C=ms(x,t.BYTES);return C[C.length-1]|=m&_t?128:0,C}toHex(){return lr(this.toRawBytes())}}y.BASE=new y(e.Gx,e.Gy,_t,l(e.Gx*e.Gy)),y.ZERO=new y(Gt,_t,_t,Gt);const{BASE:I,ZERO:R}=y,T=Tl(y,a*8);function L(k){return De(k,n)}function P(k){return L(Pr(k))}function U(k){const m=a;k=Qe("private key",k,m);const x=Qe("hashed private key",o(k),2*m),C=p(x.slice(0,m)),D=x.slice(m,2*m),F=P(C),G=I.multiply(F),Z=G.toRawBytes();return{head:C,prefix:D,scalar:F,point:G,pointBytes:Z}}function he(k){return U(k).pointBytes}function Q(k=new Uint8Array,...m){const x=fr(...m);return P(o(b(x,Qe("context",k),!!s)))}function V(k,m,x={}){k=Qe("message",k),s&&(k=s(k));const{prefix:C,scalar:D,pointBytes:F}=U(m),G=Q(x.context,C,k),Z=I.multiply(G).toRawBytes(),Y=Q(x.context,Z,F,k),re=L(G+Y*D);Mt("signature.s",re,Gt,n);const se=fr(Z,ms(re,t.BYTES));return Qe("result",se,a*2)}const pe=U1;function _(k,m,x,C=pe){const{context:D,zip215:F}=C,G=t.BYTES;k=Qe("signature",k,2*G),m=Qe("message",m),F!==void 0&&Ln("zip215",F),s&&(m=s(m));const Z=Pr(k.slice(G,2*G));let Y,re,se;try{Y=y.fromHex(x,F),re=y.fromHex(k.slice(0,G),F),se=I.multiplyUnsafe(Z)}catch{return!1}if(!F&&Y.isSmallOrder())return!1;const ye=Q(D,re.toRawBytes(),Y.toRawBytes(),m);return re.add(Y.multiplyUnsafe(ye)).subtract(se).clearCofactor().equals(y.ZERO)}return I._setWindowSize(8),{CURVE:e,getPublicKey:he,sign:V,verify:_,ExtendedPoint:y,utils:{getExtendedPublicKey:U,randomPrivateKey:()=>i(t.BYTES),precompute(k=8,m=y.BASE){return m._setWindowSize(k),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ra=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Pc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const D1=BigInt(1),Cc=BigInt(2);BigInt(3);const F1=BigInt(5),M1=BigInt(8);function H1(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),o=Ra,a=r*r%o*r%o,c=Ve(a,Cc,o)*a%o,u=Ve(c,D1,o)*r%o,l=Ve(u,F1,o)*u%o,f=Ve(l,e,o)*l%o,h=Ve(f,t,o)*f%o,p=Ve(h,n,o)*h%o,b=Ve(p,s,o)*p%o,g=Ve(b,s,o)*p%o,d=Ve(g,e,o)*l%o;return{pow_p_5_8:Ve(d,Cc,o)*r%o,b2:a}}function K1(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function W1(r,e){const t=Ra,n=De(e*e*e,t),s=De(n*n*e,t),o=H1(r*s).pow_p_5_8;let i=De(r*n*o,t);const a=De(e*i*i,t),c=i,u=De(i*Pc,t),l=a===r,f=a===De(-r,t),h=a===De(-r*Pc,t);return l&&(i=c),(f||h)&&(i=u),_1(i,t)&&(i=De(-i,t)),{isValid:l||f,value:i}}const q1=Po(Ra,void 0,!0),j1={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:q1,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:M1,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:h1,randomBytes:El,adjustScalarBytes:K1,uvRatio:W1},Jr=z1(j1);var qs=Jf.Buffer;function V1(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=qs.from(p)),!qs.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var b=0,g=0,d=0,w=p.length;d!==w&&p[d]===0;)d++,b++;for(var S=(w-d)*u+1>>>0,y=new Uint8Array(S);d!==w;){for(var I=p[d],R=0,T=S-1;(I!==0||R<g)&&T!==-1;T--,R++)I+=256*y[T]>>>0,y[T]=I%i>>>0,I=I/i>>>0;if(I!==0)throw new Error("Non-zero carry");g=R,d++}for(var L=S-g;L!==S&&y[L]===0;)L++;for(var P=a.repeat(b);L<S;++L)P+=r.charAt(y[L]);return P}function f(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return qs.alloc(0);for(var b=0,g=0,d=0;p[b]===a;)g++,b++;for(var w=(p.length-b)*c+1>>>0,S=new Uint8Array(w);b<p.length;){var y=e[p.charCodeAt(b)];if(y===255)return;for(var I=0,R=w-1;(y!==0||I<d)&&R!==-1;R--,I++)y+=i*S[R]>>>0,S[R]=y%256>>>0,y=y/256>>>0;if(y!==0)throw new Error("Non-zero carry");d=I,b++}for(var T=w-d;T!==w&&S[T]===0;)T++;var L=qs.allocUnsafe(g+(w-T));L.fill(0,0,g);for(var P=g;T!==w;)L[P++]=S[T++];return L}function h(p){var b=f(p);if(b)return b;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:f,decode:h}}var G1=V1,Y1=G1,Z1="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Pl=Y1(Z1);const ht=As(Pl);function Oc(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function X1(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function La(r,...e){if(!X1(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function co(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Cl(r,e){La(r);const t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const J1=r=>new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4)),ki=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),rn=(r,e)=>r<<32-e|r>>>e,Uc=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,Q1=r=>r<<24&4278190080|r<<8&16711680|r>>>8&65280|r>>>24&255;function Nc(r){for(let e=0;e<r.length;e++)r[e]=Q1(r[e])}function eg(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Ta(r){return typeof r=="string"&&(r=eg(r)),La(r),r}class Ol{clone(){return this._cloneInto()}}function Ul(r){const e=n=>r().update(Ta(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function tg(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}const ng=(r,e,t)=>r&e^~r&t,rg=(r,e,t)=>r&e^r&t^e&t;class sg extends Ol{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=ki(this.buffer)}update(e){co(this);const{view:t,buffer:n,blockLen:s}=this;e=Ta(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=ki(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){co(this),Cl(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let f=i;f<s;f++)t[f]=0;tg(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=ki(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)a.setUint32(4*f,l[f],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}}const og=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Nn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),zn=new Uint32Array(64);let ig=class extends sg{constructor(){super(64,32,8,!1),this.A=Nn[0]|0,this.B=Nn[1]|0,this.C=Nn[2]|0,this.D=Nn[3]|0,this.E=Nn[4]|0,this.F=Nn[5]|0,this.G=Nn[6]|0,this.H=Nn[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let f=0;f<16;f++,t+=4)zn[f]=e.getUint32(t,!1);for(let f=16;f<64;f++){const h=zn[f-15],p=zn[f-2],b=rn(h,7)^rn(h,18)^h>>>3,g=rn(p,17)^rn(p,19)^p>>>10;zn[f]=g+zn[f-7]+b+zn[f-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let f=0;f<64;f++){const h=rn(a,6)^rn(a,11)^rn(a,25),p=l+h+ng(a,c,u)+og[f]+zn[f]|0,g=(rn(n,2)^rn(n,13)^rn(n,22))+rg(n,s,o)|0;l=u,u=c,c=a,a=i+p|0,i=o,o=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){zn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const zc=Ul(()=>new ig);var dt={};function An(r,e,t){return e<=r&&r<=t}function Co(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function ag(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function cg(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var uo=-1;function $a(r){this.tokens=[].slice.call(r)}$a.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():uo},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var Kr=-1;function Si(r,e){if(r)throw TypeError("Decoder error");return e||65533}var lo="utf-8";function fo(r,e){if(!(this instanceof fo))return new fo(r,e);if(r=r!==void 0?String(r).toLowerCase():lo,r!==lo)throw new Error("Encoding not supported. Only utf-8 is supported");e=Co(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}fo.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=Co(t),this._streaming||(this._decoder=new ug({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new $a(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Kr);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Kr)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),cg(o)}};function ho(r,e){if(!(this instanceof ho))return new ho(r,e);if(r=r!==void 0?String(r).toLowerCase():lo,r!==lo)throw new Error("Encoding not supported. Only utf-8 is supported");e=Co(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}ho.prototype={encode:function(e,t){e=e?String(e):"",t=Co(t),this._streaming||(this._encoder=new lg(this._options)),this._streaming=!!t.stream;for(var n=[],s=new $a(ag(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Kr);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Kr;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function ug(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===uo&&s!==0)return s=0,Si(e);if(c===uo)return Kr;if(s===0){if(An(c,0,127))return c;if(An(c,194,223))s=1,t=c-192;else if(An(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(An(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return Si(e);return t=t<<6*s,null}if(!An(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),Si(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var u=t;return t=s=n=0,u}}function lg(r){r.fatal,this.handler=function(e,t){if(t===uo)return Kr;if(An(t,0,127))return t;var n,s;An(t,128,2047)?(n=1,s=192):An(t,2048,65535)?(n=2,s=224):An(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const fg=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:fo,TextEncoder:ho},Symbol.toStringTag,{value:"Module"})),dg=Bs(fg);var hg=Xe&&Xe.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),pg=Xe&&Xe.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),yn=Xe&&Xe.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},gg=Xe&&Xe.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&hg(e,r,t);return pg(e,r),e},Nl=Xe&&Xe.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(dt,"__esModule",{value:!0});var zl=dt.deserializeUnchecked=Wl=dt.deserialize=Kl=dt.serialize=dt.BinaryReader=dt.BinaryWriter=dt.BorshError=dt.baseDecode=dt.baseEncode=void 0;const Kn=Nl(Qf),Dl=Nl(Pl),yg=gg(dg),bg=typeof TextDecoder!="function"?yg.TextDecoder:TextDecoder,wg=new bg("utf-8",{fatal:!0});function mg(r){return typeof r=="string"&&(r=O.Buffer.from(r,"utf8")),Dl.default.encode(O.Buffer.from(r))}dt.baseEncode=mg;function kg(r){return O.Buffer.from(Dl.default.decode(r))}dt.baseDecode=kg;const xi=1024;class It extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}dt.BorshError=It;class Fl{constructor(){this.buf=O.Buffer.alloc(xi),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=O.Buffer.concat([this.buf,O.Buffer.alloc(xi)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Kn.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Kn.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Kn.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(O.Buffer.from(new Kn.default(e).toArray("le",64)))}writeBuffer(e){this.buf=O.Buffer.concat([O.Buffer.from(this.buf.subarray(0,this.length)),e,O.Buffer.alloc(xi)]),this.length+=e.length}writeString(e){this.maybeResize();const t=O.Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(O.Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}dt.BinaryWriter=Fl;function bn(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new It("Reached the end of buffer when deserializing")}throw o}}}class Nt{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new Kn.default(e,"le")}readU128(){const e=this.readBuffer(16);return new Kn.default(e,"le")}readU256(){const e=this.readBuffer(32);return new Kn.default(e,"le")}readU512(){const e=this.readBuffer(64);return new Kn.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new It(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return wg.decode(t)}catch(n){throw new It(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}}yn([bn],Nt.prototype,"readU8",null);yn([bn],Nt.prototype,"readU16",null);yn([bn],Nt.prototype,"readU32",null);yn([bn],Nt.prototype,"readU64",null);yn([bn],Nt.prototype,"readU128",null);yn([bn],Nt.prototype,"readU256",null);yn([bn],Nt.prototype,"readU512",null);yn([bn],Nt.prototype,"readString",null);yn([bn],Nt.prototype,"readFixedArray",null);yn([bn],Nt.prototype,"readArray",null);dt.BinaryReader=Nt;function Ml(r){return r.charAt(0).toUpperCase()+r.slice(1)}function Jn(r,e,t,n,s){try{if(typeof n=="string")s[`write${Ml(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new It(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new It(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)Jn(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{Jn(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),Jn(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{Jn(r,e,i,n.key,s),Jn(r,e,o,n.value,s)});break}default:throw new It(`FieldType ${n} unrecognized`)}else Hl(r,t,s)}catch(o){throw o instanceof It&&o.addToFieldPath(e),o}}function Hl(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new It(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{Jn(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),Jn(r,i,e[i],a,t);break}}}else throw new It(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Sg(r,e,t=Fl){const n=new t;return Hl(r,e,n),n.toArray()}var Kl=dt.serialize=Sg;function Qn(r,e,t,n){try{if(typeof t=="string")return n[`read${Ml(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(Qn(r,null,t[0],n));return s}else return n.readArray(()=>Qn(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?Qn(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=Qn(r,e,t.key,n),c=Qn(r,e,t.value,n);s.set(a,c)}return s}return Pa(r,t,n)}catch(s){throw s instanceof It&&s.addToFieldPath(e),s}}function Pa(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new It(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=Qn(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new It(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=Qn(r,o,i,t);return new e({[o]:a})}throw new It(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function xg(r,e,t,n=Nt){const s=new n(t),o=Pa(r,e,s);if(s.offset<t.length)throw new It(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Wl=dt.deserialize=xg;function Eg(r,e,t,n=Nt){const s=new n(t);return Pa(r,e,s)}zl=dt.deserializeUnchecked=Eg;var B={};Object.defineProperty(B,"__esModule",{value:!0});B.s16=B.s8=B.nu64be=B.u48be=B.u40be=B.u32be=B.u24be=B.u16be=lt=B.nu64=B.u48=B.u40=ee=B.u32=B.u24=Dt=B.u16=Se=B.u8=qn=B.offset=B.greedy=B.Constant=B.UTF8=B.CString=B.Blob=B.Boolean=B.BitField=B.BitStructure=B.VariantLayout=B.Union=B.UnionLayoutDiscriminator=B.UnionDiscriminator=B.Structure=B.Sequence=B.DoubleBE=B.Double=B.FloatBE=B.Float=B.NearInt64BE=B.NearInt64=B.NearUInt64BE=B.NearUInt64=B.IntBE=B.Int=B.UIntBE=B.UInt=B.OffsetLayout=B.GreedyCount=B.ExternalLayout=B.bindConstructorLayout=B.nameWithProperty=B.Layout=B.uint8ArrayToBuffer=B.checkUint8Array=void 0;B.constant=B.utf8=B.cstr=Ne=B.blob=B.unionLayoutDiscriminator=B.union=pt=B.seq=B.bits=te=B.struct=B.f64be=B.f64=B.f32be=B.f32=B.ns64be=B.s48be=B.s40be=B.s32be=B.s24be=B.s16be=Ct=B.ns64=B.s48=B.s40=B.s32=B.s24=void 0;const Ca=O;function Qr(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}B.checkUint8Array=Qr;function Ie(r){return Qr(r),Ca.Buffer.from(r.buffer,r.byteOffset,r.length)}B.uint8ArrayToBuffer=Ie;class $e{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}B.Layout=$e;function Oa(r,e){return e.property?r+"["+e.property+"]":r}B.nameWithProperty=Oa;function Ig(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof $e))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}B.bindConstructorLayout=Ig;class $t extends $e{isCount(){throw new Error("ExternalLayout is abstract")}}B.ExternalLayout=$t;class ql extends $t{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Qr(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}B.GreedyCount=ql;class Ua extends $t{constructor(e,t=0,n){if(!(e instanceof $e))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Kt||this.layout instanceof Zt}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}B.OffsetLayout=Ua;class Kt extends $e{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ie(e).readUIntLE(t,this.span)}encode(e,t,n=0){return Ie(t).writeUIntLE(e,n,this.span),this.span}}B.UInt=Kt;class Zt extends $e{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ie(e).readUIntBE(t,this.span)}encode(e,t,n=0){return Ie(t).writeUIntBE(e,n,this.span),this.span}}B.UIntBE=Zt;class wr extends $e{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ie(e).readIntLE(t,this.span)}encode(e,t,n=0){return Ie(t).writeIntLE(e,n,this.span),this.span}}B.Int=wr;class es extends $e{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Ie(e).readIntBE(t,this.span)}encode(e,t,n=0){return Ie(t).writeIntBE(e,n,this.span),this.span}}B.IntBE=es;const ji=Math.pow(2,32);function Oo(r){const e=Math.floor(r/ji),t=r-e*ji;return{hi32:e,lo32:t}}function Uo(r,e){return r*ji+e}class jl extends $e{constructor(e){super(8,e)}decode(e,t=0){const n=Ie(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return Uo(o,s)}encode(e,t,n=0){const s=Oo(e),o=Ie(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}}B.NearUInt64=jl;class Vl extends $e{constructor(e){super(8,e)}decode(e,t=0){const n=Ie(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return Uo(s,o)}encode(e,t,n=0){const s=Oo(e),o=Ie(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}B.NearUInt64BE=Vl;class Gl extends $e{constructor(e){super(8,e)}decode(e,t=0){const n=Ie(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return Uo(o,s)}encode(e,t,n=0){const s=Oo(e),o=Ie(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}}B.NearInt64=Gl;class Yl extends $e{constructor(e){super(8,e)}decode(e,t=0){const n=Ie(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return Uo(s,o)}encode(e,t,n=0){const s=Oo(e),o=Ie(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}B.NearInt64BE=Yl;class Zl extends $e{constructor(e){super(4,e)}decode(e,t=0){return Ie(e).readFloatLE(t)}encode(e,t,n=0){return Ie(t).writeFloatLE(e,n),4}}B.Float=Zl;class Xl extends $e{constructor(e){super(4,e)}decode(e,t=0){return Ie(e).readFloatBE(t)}encode(e,t,n=0){return Ie(t).writeFloatBE(e,n),4}}B.FloatBE=Xl;class Jl extends $e{constructor(e){super(8,e)}decode(e,t=0){return Ie(e).readDoubleLE(t)}encode(e,t,n=0){return Ie(t).writeDoubleLE(e,n),8}}B.Double=Jl;class Ql extends $e{constructor(e){super(8,e)}decode(e,t=0){return Ie(e).readDoubleBE(t)}encode(e,t,n=0){return Ie(t).writeDoubleBE(e,n),8}}B.DoubleBE=Ql;class ef extends $e{constructor(e,t,n){if(!(e instanceof $e))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof $t&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof $t)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof $t&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof $t&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof $t&&this.count.encode(e.length,t,n),o}}B.Sequence=ef;class tf extends $e{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof $e,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Qr(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}B.Structure=tf;class Na{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}B.UnionDiscriminator=Na;class po extends Na{constructor(e,t){if(!(e instanceof $t&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}B.UnionLayoutDiscriminator=po;class za extends $e{constructor(e,t,n){let s;if(e instanceof Kt||e instanceof Zt)s=new po(new Ua(e));else if(e instanceof $t&&e.isCount())s=new po(e);else if(e instanceof Na)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof $e))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof Kt||e instanceof Zt)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Kt||e instanceof Zt,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new nf(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}B.Union=za;class nf extends $e{constructor(e,t,n,s){if(!(e instanceof za))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof $e))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}B.VariantLayout=nf;function Ar(r){return 0>r&&(r+=4294967296),r}class Da extends $e{constructor(e,t,n){if(!(e instanceof Kt||e instanceof Zt))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Ar(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new Fa(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new rf(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}B.BitStructure=Da;class Fa{constructor(e,t,n){if(!(e instanceof Da))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Ar(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return Ar(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Ar(e&this.valueMask))throw new TypeError(Oa("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=Ar(e<<this.start);this.container._packedSetValue(Ar(t&~this.wordMask)|n)}}B.BitField=Fa;let rf=class extends Fa{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};B.Boolean=rf;class sf extends $e{constructor(e,t){if(!(e instanceof $t&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof $t||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),Ie(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof $t&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(Oa("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=Ie(e);return Ie(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof $t&&this.length.encode(s,t,n),s}}B.Blob=sf;class of extends $e{constructor(e){super(-1,e)}getSpan(e,t=0){Qr(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return Ie(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Ca.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=Ie(t);return s.copy(i,n),i[n+o]=0,o+1}}B.CString=of;class af extends $e{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Qr(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return Ie(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Ca.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(Ie(t),n),o}}B.UTF8=af;class cf extends $e{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}B.Constant=cf;B.greedy=(r,e)=>new ql(r,e);var qn=B.offset=(r,e,t)=>new Ua(r,e,t),Se=B.u8=r=>new Kt(1,r),Dt=B.u16=r=>new Kt(2,r);B.u24=r=>new Kt(3,r);var ee=B.u32=r=>new Kt(4,r);B.u40=r=>new Kt(5,r);B.u48=r=>new Kt(6,r);var lt=B.nu64=r=>new jl(r);B.u16be=r=>new Zt(2,r);B.u24be=r=>new Zt(3,r);B.u32be=r=>new Zt(4,r);B.u40be=r=>new Zt(5,r);B.u48be=r=>new Zt(6,r);B.nu64be=r=>new Vl(r);B.s8=r=>new wr(1,r);B.s16=r=>new wr(2,r);B.s24=r=>new wr(3,r);B.s32=r=>new wr(4,r);B.s40=r=>new wr(5,r);B.s48=r=>new wr(6,r);var Ct=B.ns64=r=>new Gl(r);B.s16be=r=>new es(2,r);B.s24be=r=>new es(3,r);B.s32be=r=>new es(4,r);B.s40be=r=>new es(5,r);B.s48be=r=>new es(6,r);B.ns64be=r=>new Yl(r);B.f32=r=>new Zl(r);B.f32be=r=>new Xl(r);B.f64=r=>new Jl(r);B.f64be=r=>new Ql(r);var te=B.struct=(r,e,t)=>new tf(r,e,t);B.bits=(r,e,t)=>new Da(r,e,t);var pt=B.seq=(r,e,t)=>new ef(r,e,t);B.union=(r,e,t)=>new za(r,e,t);B.unionLayoutDiscriminator=(r,e)=>new po(r,e);var Ne=B.blob=(r,e)=>new sf(r,e);B.cstr=r=>new of(r);B.utf8=(r,e)=>new af(r,e);B.constant=(r,e)=>new cf(r,e);var Cs={};Object.defineProperty(Cs,"__esModule",{value:!0});function vg(r){{const e=O.Buffer.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Ag=Cs.toBigIntLE=vg;function Bg(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Cs.toBigIntBE=Bg;function _g(r,e){{const t=r.toString(16),n=O.Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var uf=Cs.toBufferLE=_g;function Rg(r,e){{const t=r.toString(16);return O.Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Cs.toBufferBE=Rg;class Lg extends TypeError{constructor(e,t){let n;const{message:s,explanation:o,...i}=e,{path:a}=e,c=a.length===0?s:`At path: ${a.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function Tg(r){return Os(r)&&typeof r[Symbol.iterator]=="function"}function Os(r){return typeof r=="object"&&r!=null}function go(r){return Os(r)&&!Array.isArray(r)}function Jt(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function $g(r){const{done:e,value:t}=r.next();return e?void 0:t}function Pg(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${Jt(n)}\``}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Dc(r,e,t,n){Tg(r)||(r=[r]);for(const s of r){const o=Pg(s,e,t,n);o&&(yield o)}}function*Ma(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s,mask:i};o&&(r=e.coercer(r,a));let c="valid";for(const u of e.validator(r,a))u.explanation=t.message,c="not_valid",yield[u,void 0];for(let[u,l,f]of e.entries(r,a)){const h=Ma(l,f,{path:u===void 0?n:[...n,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i,message:t.message});for(const p of h)p[0]?(c=p[0].refinement!=null?"not_refined":"not_valid",yield[p[0],void 0]):o&&(l=p[1],u===void 0?r=l:r instanceof Map?r.set(u,l):r instanceof Set?r.add(l):Os(r)&&(l!==void 0||u in r)&&(r[u]=l))}if(c!=="not_valid")for(const u of e.refiner(r,a))u.explanation=t.message,c="not_refined",yield[u,void 0];c==="valid"&&(yield[void 0,r])}let wn=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return Dc(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return Dc(l,u,this,c)}:this.refiner=()=>[]}assert(e,t){return lf(e,this,t)}create(e,t){return W(e,this,t)}is(e){return ff(e,this)}mask(e,t){return Cg(e,this,t)}validate(e,t={}){return Us(e,this,t)}};function lf(r,e,t){const n=Us(r,e,{message:t});if(n[0])throw n[0]}function W(r,e,t){const n=Us(r,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function Cg(r,e,t){const n=Us(r,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function ff(r,e){return!Us(r,e)[0]}function Us(r,e,t={}){const n=Ma(r,e,t),s=$g(n);return s[0]?[new Lg(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function mr(r,e){return new wn({type:r,schema:null,validator:e})}function Og(){return mr("any",()=>!0)}function q(r){return new wn({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${Jt(e)}`}})}function dn(){return mr("boolean",r=>typeof r=="boolean")}function Ha(r){return mr("instance",e=>e instanceof r||`Expected a \`${r.name}\` instance, but received: ${Jt(e)}`)}function He(r){const e=Jt(r),t=typeof r;return new wn({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${e}\`, but received: ${Jt(n)}`}})}function Ug(){return mr("never",()=>!1)}function j(r){return new wn({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function E(){return mr("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${Jt(r)}`)}function ce(r){return new wn({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function df(r,e){return new wn({type:"record",schema:null,*entries(t){if(Os(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return go(t)||`Expected an object, but received: ${Jt(t)}`},coercer(t){return go(t)?{...t}:t}})}function M(){return mr("string",r=>typeof r=="string"||`Expected a string, but received: ${Jt(r)}`)}function Ka(r){const e=Ug();return new wn({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Jt(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function z(r){const e=Object.keys(r);return new wn({type:"type",schema:r,*entries(t){if(Os(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return go(t)||`Expected an object, but received: ${Jt(t)}`},coercer(t){return go(t)?{...t}:t}})}function At(r){const e=r.map(t=>t.type).join(" | ");return new wn({type:"union",schema:null,coercer(t,n){for(const s of r){const[o,i]=s.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){const s=[];for(const o of r){const[...i]=Ma(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${Jt(t)}`,...s]}})}function ts(){return mr("unknown",()=>!0)}function Ns(r,e,t){return new wn({...r,coercer:(n,s)=>ff(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}var js,Ng=new Uint8Array(16);function hf(){if(!js&&(js=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!js))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return js(Ng)}const zg=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function No(r){return typeof r=="string"&&zg.test(r)}var ct=[];for(var Ei=0;Ei<256;++Ei)ct.push((Ei+256).toString(16).substr(1));function zo(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(ct[r[e+0]]+ct[r[e+1]]+ct[r[e+2]]+ct[r[e+3]]+"-"+ct[r[e+4]]+ct[r[e+5]]+"-"+ct[r[e+6]]+ct[r[e+7]]+"-"+ct[r[e+8]]+ct[r[e+9]]+"-"+ct[r[e+10]]+ct[r[e+11]]+ct[r[e+12]]+ct[r[e+13]]+ct[r[e+14]]+ct[r[e+15]]).toLowerCase();if(!No(t))throw TypeError("Stringified UUID is invalid");return t}var Fc,Ii,vi=0,Ai=0;function Dg(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||Fc,i=r.clockseq!==void 0?r.clockseq:Ii;if(o==null||i==null){var a=r.random||(r.rng||hf)();o==null&&(o=Fc=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Ii=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),u=r.nsecs!==void 0?r.nsecs:Ai+1,l=c-vi+(u-Ai)/1e4;if(l<0&&r.clockseq===void 0&&(i=i+1&16383),(l<0||c>vi)&&r.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");vi=c,Ai=u,Ii=i,c+=122192928e5;var f=((c&268435455)*1e4+u)%4294967296;s[n++]=f>>>24&255,s[n++]=f>>>16&255,s[n++]=f>>>8&255,s[n++]=f&255;var h=c/4294967296*1e4&268435455;s[n++]=h>>>8&255,s[n++]=h&255,s[n++]=h>>>24&15|16,s[n++]=h>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var p=0;p<6;++p)s[n+p]=o[p];return e||zo(s)}function pf(r){if(!No(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function Fg(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var Mg="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Hg="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function gf(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=Fg(s)),typeof o=="string"&&(o=pf(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return zo(c)}try{n.name=r}catch{}return n.DNS=Mg,n.URL=Hg,n}function Kg(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return Wg(qg(jg(r),r.length*8))}function Wg(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function yf(r){return(r+64>>>9<<4)+14+1}function qg(r,e){r[e>>5]|=128<<e%32,r[yf(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,u=s,l=o;t=mt(t,n,s,o,r[i],7,-680876936),o=mt(o,t,n,s,r[i+1],12,-389564586),s=mt(s,o,t,n,r[i+2],17,606105819),n=mt(n,s,o,t,r[i+3],22,-1044525330),t=mt(t,n,s,o,r[i+4],7,-176418897),o=mt(o,t,n,s,r[i+5],12,1200080426),s=mt(s,o,t,n,r[i+6],17,-1473231341),n=mt(n,s,o,t,r[i+7],22,-45705983),t=mt(t,n,s,o,r[i+8],7,1770035416),o=mt(o,t,n,s,r[i+9],12,-1958414417),s=mt(s,o,t,n,r[i+10],17,-42063),n=mt(n,s,o,t,r[i+11],22,-1990404162),t=mt(t,n,s,o,r[i+12],7,1804603682),o=mt(o,t,n,s,r[i+13],12,-40341101),s=mt(s,o,t,n,r[i+14],17,-1502002290),n=mt(n,s,o,t,r[i+15],22,1236535329),t=kt(t,n,s,o,r[i+1],5,-165796510),o=kt(o,t,n,s,r[i+6],9,-1069501632),s=kt(s,o,t,n,r[i+11],14,643717713),n=kt(n,s,o,t,r[i],20,-373897302),t=kt(t,n,s,o,r[i+5],5,-701558691),o=kt(o,t,n,s,r[i+10],9,38016083),s=kt(s,o,t,n,r[i+15],14,-660478335),n=kt(n,s,o,t,r[i+4],20,-405537848),t=kt(t,n,s,o,r[i+9],5,568446438),o=kt(o,t,n,s,r[i+14],9,-1019803690),s=kt(s,o,t,n,r[i+3],14,-187363961),n=kt(n,s,o,t,r[i+8],20,1163531501),t=kt(t,n,s,o,r[i+13],5,-1444681467),o=kt(o,t,n,s,r[i+2],9,-51403784),s=kt(s,o,t,n,r[i+7],14,1735328473),n=kt(n,s,o,t,r[i+12],20,-1926607734),t=St(t,n,s,o,r[i+5],4,-378558),o=St(o,t,n,s,r[i+8],11,-2022574463),s=St(s,o,t,n,r[i+11],16,1839030562),n=St(n,s,o,t,r[i+14],23,-35309556),t=St(t,n,s,o,r[i+1],4,-1530992060),o=St(o,t,n,s,r[i+4],11,1272893353),s=St(s,o,t,n,r[i+7],16,-155497632),n=St(n,s,o,t,r[i+10],23,-1094730640),t=St(t,n,s,o,r[i+13],4,681279174),o=St(o,t,n,s,r[i],11,-358537222),s=St(s,o,t,n,r[i+3],16,-722521979),n=St(n,s,o,t,r[i+6],23,76029189),t=St(t,n,s,o,r[i+9],4,-640364487),o=St(o,t,n,s,r[i+12],11,-421815835),s=St(s,o,t,n,r[i+15],16,530742520),n=St(n,s,o,t,r[i+2],23,-995338651),t=xt(t,n,s,o,r[i],6,-198630844),o=xt(o,t,n,s,r[i+7],10,1126891415),s=xt(s,o,t,n,r[i+14],15,-1416354905),n=xt(n,s,o,t,r[i+5],21,-57434055),t=xt(t,n,s,o,r[i+12],6,1700485571),o=xt(o,t,n,s,r[i+3],10,-1894986606),s=xt(s,o,t,n,r[i+10],15,-1051523),n=xt(n,s,o,t,r[i+1],21,-2054922799),t=xt(t,n,s,o,r[i+8],6,1873313359),o=xt(o,t,n,s,r[i+15],10,-30611744),s=xt(s,o,t,n,r[i+6],15,-1560198380),n=xt(n,s,o,t,r[i+13],21,1309151649),t=xt(t,n,s,o,r[i+4],6,-145523070),o=xt(o,t,n,s,r[i+11],10,-1120210379),s=xt(s,o,t,n,r[i+2],15,718787259),n=xt(n,s,o,t,r[i+9],21,-343485551),t=Wn(t,a),n=Wn(n,c),s=Wn(s,u),o=Wn(o,l)}return[t,n,s,o]}function jg(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(yf(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function Wn(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function Vg(r,e){return r<<e|r>>>32-e}function Do(r,e,t,n,s,o){return Wn(Vg(Wn(Wn(e,r),Wn(n,o)),s),t)}function mt(r,e,t,n,s,o,i){return Do(e&t|~e&n,r,e,s,o,i)}function kt(r,e,t,n,s,o,i){return Do(e&n|t&~n,r,e,s,o,i)}function St(r,e,t,n,s,o,i){return Do(e^t^n,r,e,s,o,i)}function xt(r,e,t,n,s,o,i){return Do(t^(e|~n),r,e,s,o,i)}var Gg=gf("v3",48,Kg);function Yg(r,e,t){r=r||{};var n=r.random||(r.rng||hf)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return zo(n)}function Zg(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function Bi(r,e){return r<<e|r>>>32-e}function Xg(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=r[c*64+l*4]<<24|r[c*64+l*4+1]<<16|r[c*64+l*4+2]<<8|r[c*64+l*4+3];a[c]=u}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var f=0;f<i;++f){for(var h=new Uint32Array(80),p=0;p<16;++p)h[p]=a[f][p];for(var b=16;b<80;++b)h[b]=Bi(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);for(var g=t[0],d=t[1],w=t[2],S=t[3],y=t[4],I=0;I<80;++I){var R=Math.floor(I/20),T=Bi(g,5)+Zg(R,d,w,S)+y+e[R]+h[I]>>>0;y=S,S=w,w=Bi(d,30)>>>0,d=g,g=T}t[0]=t[0]+g>>>0,t[1]=t[1]+d>>>0,t[2]=t[2]+w>>>0,t[3]=t[3]+S>>>0,t[4]=t[4]+y>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Jg=gf("v5",80,Xg);const Qg="00000000-0000-0000-0000-000000000000";function ey(r){if(!No(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const ty=Object.freeze(Object.defineProperty({__proto__:null,NIL:Qg,parse:pf,stringify:zo,v1:Dg,v3:Gg,v4:Yg,v5:Jg,validate:No,version:ey},Symbol.toStringTag,{value:"Module"})),bf=Bs(ty),ny=bf.v4,ry=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return ny()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var sy=ry;const oy=bf.v4,iy=sy,Ss=function(r,e){if(!(this instanceof Ss))return new Ss(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return oy()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};var ay=Ss;Ss.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=iy(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return n(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,n)}),o};Ss.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};const cy=As(ay);var wf={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function o(c,u,l,f,h){if(typeof l!="function")throw new TypeError("The listener must be a function");var p=new s(l,f||c,h),b=t?t+u:u;return c._events[b]?c._events[b].fn?c._events[b]=[c._events[b],p]:c._events[b].push(p):(c._events[b]=p,c._eventsCount++),c}function i(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,f;if(this._eventsCount===0)return u;for(f in l=this._events)e.call(l,f)&&u.push(t?f.slice(1):f);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,f=this._events[l];if(!f)return[];if(f.fn)return[f.fn];for(var h=0,p=f.length,b=new Array(p);h<p;h++)b[h]=f[h].fn;return b},a.prototype.listenerCount=function(u){var l=t?t+u:u,f=this._events[l];return f?f.fn?1:f.length:0},a.prototype.emit=function(u,l,f,h,p,b){var g=t?t+u:u;if(!this._events[g])return!1;var d=this._events[g],w=arguments.length,S,y;if(d.fn){switch(d.once&&this.removeListener(u,d.fn,void 0,!0),w){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,l),!0;case 3:return d.fn.call(d.context,l,f),!0;case 4:return d.fn.call(d.context,l,f,h),!0;case 5:return d.fn.call(d.context,l,f,h,p),!0;case 6:return d.fn.call(d.context,l,f,h,p,b),!0}for(y=1,S=new Array(w-1);y<w;y++)S[y-1]=arguments[y];d.fn.apply(d.context,S)}else{var I=d.length,R;for(y=0;y<I;y++)switch(d[y].once&&this.removeListener(u,d[y].fn,void 0,!0),w){case 1:d[y].fn.call(d[y].context);break;case 2:d[y].fn.call(d[y].context,l);break;case 3:d[y].fn.call(d[y].context,l,f);break;case 4:d[y].fn.call(d[y].context,l,f,h);break;default:if(!S)for(R=1,S=new Array(w-1);R<w;R++)S[R-1]=arguments[R];d[y].fn.apply(d[y].context,S)}}return!0},a.prototype.on=function(u,l,f){return o(this,u,l,f,!1)},a.prototype.once=function(u,l,f){return o(this,u,l,f,!0)},a.prototype.removeListener=function(u,l,f,h){var p=t?t+u:u;if(!this._events[p])return this;if(!l)return i(this,p),this;var b=this._events[p];if(b.fn)b.fn===l&&(!h||b.once)&&(!f||b.context===f)&&i(this,p);else{for(var g=0,d=[],w=b.length;g<w;g++)(b[g].fn!==l||h&&!b[g].once||f&&b[g].context!==f)&&d.push(b[g]);d.length?this._events[p]=d.length===1?d[0]:d:i(this,p)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&i(this,l)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(wf);var uy=wf.exports;const mf=As(uy);var ly=class extends mf{constructor(e,t,n){super();et(this,"socket");this.socket=new window.WebSocket(e,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=s=>this.emit("message",s.data),this.socket.onerror=s=>this.emit("error",s),this.socket.onclose=s=>{this.emit("close",s.code,s.reason)}}send(e,t,n){const s=n||t;try{this.socket.send(e),s()}catch(o){s(o)}}close(e,t){this.socket.close(e,t)}addEventListener(e,t,n){this.socket.addEventListener(e,t,n)}};function fy(r,e){return new ly(r,e)}var dy=class{encode(r){return JSON.stringify(r)}decode(r){return JSON.parse(r)}},hy=class extends mf{constructor(e,t="ws://localhost:8080",{autoconnect:n=!0,reconnect:s=!0,reconnect_interval:o=1e3,max_reconnects:i=5,...a}={},c,u){super();et(this,"address");et(this,"rpc_id");et(this,"queue");et(this,"options");et(this,"autoconnect");et(this,"ready");et(this,"reconnect");et(this,"reconnect_timer_id");et(this,"reconnect_interval");et(this,"max_reconnects");et(this,"rest_options");et(this,"current_reconnects");et(this,"generate_request_id");et(this,"socket");et(this,"webSocketFactory");et(this,"dataPack");this.webSocketFactory=e,this.queue={},this.rpc_id=0,this.address=t,this.autoconnect=n,this.ready=!1,this.reconnect=s,this.reconnect_timer_id=void 0,this.reconnect_interval=o,this.max_reconnects=i,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=c||(()=>++this.rpc_id),u?this.dataPack=u:this.dataPack=new dy,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(e,t,n,s){return!s&&typeof n=="object"&&(s=n,n=null),new Promise((o,i)=>{if(!this.ready)return i(new Error("socket not ready"));const a=this.generate_request_id(e,t),c={jsonrpc:"2.0",method:e,params:t||void 0,id:a};this.socket.send(this.dataPack.encode(c),s,u=>{if(u)return i(u);this.queue[a]={promise:[o,i]},n&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],i(new Error("reply timeout"))},n))})})}async login(e){const t=await this.call("rpc.login",e);if(!t)throw new Error("authentication failed");return t}async listMethods(){return await this.call("__listMethods")}notify(e,t){return new Promise((n,s)=>{if(!this.ready)return s(new Error("socket not ready"));const o={jsonrpc:"2.0",method:e,params:t};this.socket.send(this.dataPack.encode(o),i=>{if(i)return s(i);n()})})}async subscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.on",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed subscribing to an event '"+e+"' with: "+t[e]);return t}async unsubscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.off",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed unsubscribing from an event with: "+t);return t}close(e,t){this.socket.close(e||1e3,t)}setAutoReconnect(e){this.reconnect=e}setReconnectInterval(e){this.reconnect_interval=e}setMaxReconnects(e){this.max_reconnects=e}_connect(e,t){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,t),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:n})=>{n instanceof ArrayBuffer&&(n=O.Buffer.from(n).toString());try{n=this.dataPack.decode(n)}catch{return}if(n.notification&&this.listeners(n.notification).length){if(!Object.keys(n.params).length)return this.emit(n.notification);const s=[n.notification];if(n.params.constructor===Object)s.push(n.params);else for(let o=0;o<n.params.length;o++)s.push(n.params[o]);return Promise.resolve().then(()=>{this.emit.apply(this,s)})}if(!this.queue[n.id])return n.method?Promise.resolve().then(()=>{this.emit(n.method,n==null?void 0:n.params)}):void 0;"error"in n=="result"in n&&this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[n.id].timeout&&clearTimeout(this.queue[n.id].timeout),n.error?this.queue[n.id].promise[1](n.error):this.queue[n.id].promise[0](n.result),delete this.queue[n.id]}),this.socket.addEventListener("error",n=>this.emit("error",n)),this.socket.addEventListener("close",({code:n,reason:s})=>{this.ready&&setTimeout(()=>this.emit("close",n,s),0),this.ready=!1,this.socket=void 0,n!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(e,t),this.reconnect_interval)))})}};const Vs=BigInt(2**32-1),Mc=BigInt(32);function py(r,e=!1){return e?{h:Number(r&Vs),l:Number(r>>Mc&Vs)}:{h:Number(r>>Mc&Vs)|0,l:Number(r&Vs)|0}}function gy(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=py(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const yy=(r,e,t)=>r<<t|e>>>32-t,by=(r,e,t)=>e<<t|r>>>32-t,wy=(r,e,t)=>e<<t-32|r>>>64-t,my=(r,e,t)=>r<<t-32|e>>>64-t,kf=[],Sf=[],xf=[],ky=BigInt(0),fs=BigInt(1),Sy=BigInt(2),xy=BigInt(7),Ey=BigInt(256),Iy=BigInt(113);for(let r=0,e=fs,t=1,n=0;r<24;r++){[t,n]=[n,(2*t+3*n)%5],kf.push(2*(5*n+t)),Sf.push((r+1)*(r+2)/2%64);let s=ky;for(let o=0;o<7;o++)e=(e<<fs^(e>>xy)*Iy)%Ey,e&Sy&&(s^=fs<<(fs<<BigInt(o))-fs);xf.push(s)}const[vy,Ay]=gy(xf,!0),Hc=(r,e,t)=>t>32?wy(r,e,t):yy(r,e,t),Kc=(r,e,t)=>t>32?my(r,e,t):by(r,e,t);function By(r,e=24){const t=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)t[i]=r[i]^r[i+10]^r[i+20]^r[i+30]^r[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,u=t[c],l=t[c+1],f=Hc(u,l,1)^t[a],h=Kc(u,l,1)^t[a+1];for(let p=0;p<50;p+=10)r[i+p]^=f,r[i+p+1]^=h}let s=r[2],o=r[3];for(let i=0;i<24;i++){const a=Sf[i],c=Hc(s,o,a),u=Kc(s,o,a),l=kf[i];s=r[l],o=r[l+1],r[l]=c,r[l+1]=u}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=r[i+a];for(let a=0;a<10;a++)r[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}r[0]^=vy[n],r[1]^=Ay[n]}t.fill(0)}class Wa extends Ol{constructor(e,t,n,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Oc(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=J1(this.state)}keccak(){Uc||Nc(this.state32),By(this.state32,this.rounds),Uc||Nc(this.state32),this.posOut=0,this.pos=0}update(e){co(this);const{blockLen:t,state:n}=this;e=Ta(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(t-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t,t&128&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){co(this,!1),La(e),this.finish();const t=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(t.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Oc(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Cl(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new Wa(t,n,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const _y=(r,e,t)=>Ul(()=>new Wa(e,r,t)),Wc=_y(1,136,256/8),Ry=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Dn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Fn=new Uint32Array(64);class Ly extends Il{constructor(){super(64,32,8,!1),this.A=Dn[0]|0,this.B=Dn[1]|0,this.C=Dn[2]|0,this.D=Dn[3]|0,this.E=Dn[4]|0,this.F=Dn[5]|0,this.G=Dn[6]|0,this.H=Dn[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let f=0;f<16;f++,t+=4)Fn[f]=e.getUint32(t,!1);for(let f=16;f<64;f++){const h=Fn[f-15],p=Fn[f-2],b=nn(h,7)^nn(h,18)^h>>>3,g=nn(p,17)^nn(p,19)^p>>>10;Fn[f]=g+Fn[f-7]+b+Fn[f-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let f=0;f<64;f++){const h=nn(a,6)^nn(a,11)^nn(a,25),p=l+h+M0(a,c,u)+Ry[f]+Fn[f]|0,g=(nn(n,2)^nn(n,13)^nn(n,22))+H0(n,s,o)|0;l=u,u=c,c=a,a=i+p|0,i=o,o=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){Fn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ty=xl(()=>new Ly);class Ef extends Sl{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,U0(e);const n=Ia(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return ao(this),this.iHash.update(e),this}digestInto(e){ao(this),Lo(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const If=(r,e,t)=>new Ef(r,e).update(t).digest();If.create=(r,e)=>new Ef(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function qc(r){r.lowS!==void 0&&Ln("lowS",r.lowS),r.prehash!==void 0&&Ln("prehash",r.prehash)}function $y(r){const e=_a(r);Xr(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Py,hexToBytes:Cy}=E1,En={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(r,e)=>{const{Err:t}=En;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=Lr(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const o=n>127?Lr(s.length/2|128):"";return`${Lr(r)}${o}${s}${e}`},decode(r,e){const{Err:t}=En;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+c);if(u.length!==c)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const l of u)i=i<<8|l;if(n+=c,i<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(r){const{Err:e}=En;if(r<Bn)throw new e("integer: negative integers are not allowed");let t=Lr(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected assertion");return t},decode(r){const{Err:e}=En;if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return Py(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=En,s=typeof r=="string"?Cy(r):r;Ps(s);const{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("Invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:u,l}=n.decode(2,c);if(l.length)throw new e("Invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(r){const{_tlv:e,_int:t}=En,n=`${e.encode(2,t.encode(r.r))}${e.encode(2,t.encode(r.s))}`;return e.encode(48,n)}},Bn=BigInt(0),nt=BigInt(1);BigInt(2);const jc=BigInt(3);BigInt(4);function Oy(r){const e=$y(r),{Fp:t}=e,n=Po(e.n,e.nBitLength),s=e.toBytes||((g,d,w)=>{const S=d.toAffine();return fr(Uint8Array.from([4]),t.toBytes(S.x),t.toBytes(S.y))}),o=e.fromBytes||(g=>{const d=g.subarray(1),w=t.fromBytes(d.subarray(0,t.BYTES)),S=t.fromBytes(d.subarray(t.BYTES,2*t.BYTES));return{x:w,y:S}});function i(g){const{a:d,b:w}=e,S=t.sqr(g),y=t.mul(S,g);return t.add(t.add(y,t.mul(g,d)),w)}if(!t.eql(t.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return $o(g,nt,e.n)}function c(g){const{allowedPrivateKeyLengths:d,nByteLength:w,wrapPrivateKey:S,n:y}=e;if(d&&typeof g!="bigint"){if(ur(g)&&(g=lr(g)),typeof g!="string"||!d.includes(g.length))throw new Error("Invalid key");g=g.padStart(w*2,"0")}let I;try{I=typeof g=="bigint"?g:or(Qe("private key",g,w))}catch{throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof g}`)}return S&&(I=De(I,y)),Mt("private key",I,nt,y),I}function u(g){if(!(g instanceof h))throw new Error("ProjectivePoint expected")}const l=ks((g,d)=>{const{px:w,py:S,pz:y}=g;if(t.eql(y,t.ONE))return{x:w,y:S};const I=g.is0();d==null&&(d=I?t.ONE:t.inv(y));const R=t.mul(w,d),T=t.mul(S,d),L=t.mul(y,d);if(I)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:R,y:T}}),f=ks(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:d,y:w}=g.toAffine();if(!t.isValid(d)||!t.isValid(w))throw new Error("bad point: x or y not FE");const S=t.sqr(w),y=i(d);if(!t.eql(S,y))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(d,w,S){if(this.px=d,this.py=w,this.pz=S,d==null||!t.isValid(d))throw new Error("x required");if(w==null||!t.isValid(w))throw new Error("y required");if(S==null||!t.isValid(S))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:w,y:S}=d||{};if(!d||!t.isValid(w)||!t.isValid(S))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const y=I=>t.eql(I,t.ZERO);return y(w)&&y(S)?h.ZERO:new h(w,S,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const w=t.invertBatch(d.map(S=>S.pz));return d.map((S,y)=>S.toAffine(w[y])).map(h.fromAffine)}static fromHex(d){const w=h.fromAffine(o(Qe("pointHex",d)));return w.assertValidity(),w}static fromPrivateKey(d){return h.BASE.multiply(c(d))}static msm(d,w){return $l(h,n,d,w)}_setWindowSize(d){b.setWindowSize(this,d)}assertValidity(){f(this)}hasEvenY(){const{y:d}=this.toAffine();if(t.isOdd)return!t.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){u(d);const{px:w,py:S,pz:y}=this,{px:I,py:R,pz:T}=d,L=t.eql(t.mul(w,T),t.mul(I,y)),P=t.eql(t.mul(S,T),t.mul(R,y));return L&&P}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a:d,b:w}=e,S=t.mul(w,jc),{px:y,py:I,pz:R}=this;let T=t.ZERO,L=t.ZERO,P=t.ZERO,U=t.mul(y,y),he=t.mul(I,I),Q=t.mul(R,R),V=t.mul(y,I);return V=t.add(V,V),P=t.mul(y,R),P=t.add(P,P),T=t.mul(d,P),L=t.mul(S,Q),L=t.add(T,L),T=t.sub(he,L),L=t.add(he,L),L=t.mul(T,L),T=t.mul(V,T),P=t.mul(S,P),Q=t.mul(d,Q),V=t.sub(U,Q),V=t.mul(d,V),V=t.add(V,P),P=t.add(U,U),U=t.add(P,U),U=t.add(U,Q),U=t.mul(U,V),L=t.add(L,U),Q=t.mul(I,R),Q=t.add(Q,Q),U=t.mul(Q,V),T=t.sub(T,U),P=t.mul(Q,he),P=t.add(P,P),P=t.add(P,P),new h(T,L,P)}add(d){u(d);const{px:w,py:S,pz:y}=this,{px:I,py:R,pz:T}=d;let L=t.ZERO,P=t.ZERO,U=t.ZERO;const he=e.a,Q=t.mul(e.b,jc);let V=t.mul(w,I),pe=t.mul(S,R),_=t.mul(y,T),$=t.add(w,S),k=t.add(I,R);$=t.mul($,k),k=t.add(V,pe),$=t.sub($,k),k=t.add(w,y);let m=t.add(I,T);return k=t.mul(k,m),m=t.add(V,_),k=t.sub(k,m),m=t.add(S,y),L=t.add(R,T),m=t.mul(m,L),L=t.add(pe,_),m=t.sub(m,L),U=t.mul(he,k),L=t.mul(Q,_),U=t.add(L,U),L=t.sub(pe,U),U=t.add(pe,U),P=t.mul(L,U),pe=t.add(V,V),pe=t.add(pe,V),_=t.mul(he,_),k=t.mul(Q,k),pe=t.add(pe,_),_=t.sub(V,_),_=t.mul(he,_),k=t.add(k,_),V=t.mul(pe,k),P=t.add(P,V),V=t.mul(m,k),L=t.mul($,L),L=t.sub(L,V),V=t.mul($,pe),U=t.mul(m,U),U=t.add(U,V),new h(L,P,U)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return b.wNAFCached(this,d,h.normalizeZ)}multiplyUnsafe(d){Mt("scalar",d,Bn,e.n);const w=h.ZERO;if(d===Bn)return w;if(d===nt)return this;const{endo:S}=e;if(!S)return b.unsafeLadder(this,d);let{k1neg:y,k1:I,k2neg:R,k2:T}=S.splitScalar(d),L=w,P=w,U=this;for(;I>Bn||T>Bn;)I&nt&&(L=L.add(U)),T&nt&&(P=P.add(U)),U=U.double(),I>>=nt,T>>=nt;return y&&(L=L.negate()),R&&(P=P.negate()),P=new h(t.mul(P.px,S.beta),P.py,P.pz),L.add(P)}multiply(d){const{endo:w,n:S}=e;Mt("scalar",d,nt,S);let y,I;if(w){const{k1neg:R,k1:T,k2neg:L,k2:P}=w.splitScalar(d);let{p:U,f:he}=this.wNAF(T),{p:Q,f:V}=this.wNAF(P);U=b.constTimeNegate(R,U),Q=b.constTimeNegate(L,Q),Q=new h(t.mul(Q.px,w.beta),Q.py,Q.pz),y=U.add(Q),I=he.add(V)}else{const{p:R,f:T}=this.wNAF(d);y=R,I=T}return h.normalizeZ([y,I])[0]}multiplyAndAddUnsafe(d,w,S){const y=h.BASE,I=(T,L)=>L===Bn||L===nt||!T.equals(y)?T.multiplyUnsafe(L):T.multiply(L),R=I(this,w).add(I(d,S));return R.is0()?void 0:R}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:w}=e;if(d===nt)return!0;if(w)return w(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:w}=e;return d===nt?this:w?w(h,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return Ln("isCompressed",d),this.assertValidity(),s(h,this,d)}toHex(d=!0){return Ln("isCompressed",d),lr(this.toRawBytes(d))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const p=e.nBitLength,b=Tl(h,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:a}}function Uy(r){const e=_a(r);return Xr(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ny(r){const e=Uy(r),{Fp:t,n}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(_){return De(_,n)}function a(_){return qi(_,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:f}=Oy({...e,toBytes(_,$,k){const m=$.toAffine(),x=t.toBytes(m.x),C=fr;return Ln("isCompressed",k),k?C(Uint8Array.from([$.hasEvenY()?2:3]),x):C(Uint8Array.from([4]),x,t.toBytes(m.y))},fromBytes(_){const $=_.length,k=_[0],m=_.subarray(1);if($===s&&(k===2||k===3)){const x=or(m);if(!$o(x,nt,t.ORDER))throw new Error("Point is not on curve");const C=l(x);let D;try{D=t.sqrt(C)}catch(Z){const Y=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+Y)}const F=(D&nt)===nt;return(k&1)===1!==F&&(D=t.neg(D)),{x,y:D}}else if($===o&&k===4){const x=t.fromBytes(m.subarray(0,t.BYTES)),C=t.fromBytes(m.subarray(t.BYTES,2*t.BYTES));return{x,y:C}}else throw new Error(`Point of length ${$} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),h=_=>lr(Hr(_,e.nByteLength));function p(_){const $=n>>nt;return _>$}function b(_){return p(_)?i(-_):_}const g=(_,$,k)=>or(_.slice($,k));class d{constructor($,k,m){this.r=$,this.s=k,this.recovery=m,this.assertValidity()}static fromCompact($){const k=e.nByteLength;return $=Qe("compactSignature",$,k*2),new d(g($,0,k),g($,k,2*k))}static fromDER($){const{r:k,s:m}=En.toSig(Qe("DER",$));return new d(k,m)}assertValidity(){Mt("r",this.r,nt,n),Mt("s",this.s,nt,n)}addRecoveryBit($){return new d(this.r,this.s,$)}recoverPublicKey($){const{r:k,s:m,recovery:x}=this,C=T(Qe("msgHash",$));if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");const D=x===2||x===3?k+e.n:k;if(D>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const F=x&1?"03":"02",G=c.fromHex(F+h(D)),Z=a(D),Y=i(-C*Z),re=i(m*Z),se=c.BASE.multiplyAndAddUnsafe(G,Y,re);if(!se)throw new Error("point at infinify");return se.assertValidity(),se}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return Mr(this.toDERHex())}toDERHex(){return En.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Mr(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const w={isValidPrivateKey(_){try{return u(_),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const _=Ll(e.n);return P1(e.randomBytes(_),e.n)},precompute(_=8,$=c.BASE){return $._setWindowSize(_),$.multiply(BigInt(3)),$}};function S(_,$=!0){return c.fromPrivateKey(_).toRawBytes($)}function y(_){const $=ur(_),k=typeof _=="string",m=($||k)&&_.length;return $?m===s||m===o:k?m===2*s||m===2*o:_ instanceof c}function I(_,$,k=!0){if(y(_))throw new Error("first arg must be private key");if(!y($))throw new Error("second arg must be public key");return c.fromHex($).multiply(u(_)).toRawBytes(k)}const R=e.bits2int||function(_){const $=or(_),k=_.length*8-e.nBitLength;return k>0?$>>BigInt(k):$},T=e.bits2int_modN||function(_){return i(R(_))},L=Ba(e.nBitLength);function P(_){return Mt(`num < 2^${e.nBitLength}`,_,Bn,L),Hr(_,e.nByteLength)}function U(_,$,k=he){if(["recovered","canonical"].some(be=>be in k))throw new Error("sign() legacy options not supported");const{hash:m,randomBytes:x}=e;let{lowS:C,prehash:D,extraEntropy:F}=k;C==null&&(C=!0),_=Qe("msgHash",_),qc(k),D&&(_=Qe("prehashed msgHash",m(_)));const G=T(_),Z=u($),Y=[P(Z),P(G)];if(F!=null&&F!==!1){const be=F===!0?x(t.BYTES):F;Y.push(Qe("extraEntropy",be))}const re=fr(...Y),se=G;function ye(be){const me=R(be);if(!f(me))return;const ve=a(me),Ae=c.BASE.multiply(me).toAffine(),ge=i(Ae.x);if(ge===Bn)return;const Fe=i(ve*i(se+ge*Z));if(Fe===Bn)return;let qt=(Ae.x===ge?0:2)|Number(Ae.y&nt),jt=Fe;return C&&p(Fe)&&(jt=b(Fe),qt^=1),new d(ge,jt,qt)}return{seed:re,k2sig:ye}}const he={lowS:e.lowS,prehash:!1},Q={lowS:e.lowS,prehash:!1};function V(_,$,k=he){const{seed:m,k2sig:x}=U(_,$,k),C=e;return Bl(C.hash.outputLen,C.nByteLength,C.hmac)(m,x)}c.BASE._setWindowSize(8);function pe(_,$,k,m=Q){var Ae;const x=_;if($=Qe("msgHash",$),k=Qe("publicKey",k),"strict"in m)throw new Error("options.strict was renamed to lowS");qc(m);const{lowS:C,prehash:D}=m;let F,G;try{if(typeof x=="string"||ur(x))try{F=d.fromDER(x)}catch(ge){if(!(ge instanceof En.Err))throw ge;F=d.fromCompact(x)}else if(typeof x=="object"&&typeof x.r=="bigint"&&typeof x.s=="bigint"){const{r:ge,s:Fe}=x;F=new d(ge,Fe)}else throw new Error("PARSE");G=c.fromHex(k)}catch(ge){if(ge.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(C&&F.hasHighS())return!1;D&&($=e.hash($));const{r:Z,s:Y}=F,re=T($),se=a(Y),ye=i(re*se),be=i(Z*se),me=(Ae=c.BASE.multiplyAndAddUnsafe(G,ye,be))==null?void 0:Ae.toAffine();return me?i(me.x)===Z:!1}return{CURVE:e,getPublicKey:S,getSharedSecret:I,sign:V,verify:pe,ProjectivePoint:c,Signature:d,utils:w}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function zy(r){return{hash:r,hmac:(e,...t)=>If(r,e,D0(...t)),randomBytes:El}}function Dy(r,e){const t=n=>Ny({...r,...zy(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vf=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Vc=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Fy=BigInt(1),Vi=BigInt(2),Gc=(r,e)=>(r+e/Vi)/e;function My(r){const e=vf,t=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%e,l=u*u*r%e,f=Ve(l,t,e)*l%e,h=Ve(f,t,e)*l%e,p=Ve(h,Vi,e)*u%e,b=Ve(p,s,e)*p%e,g=Ve(b,o,e)*b%e,d=Ve(g,a,e)*g%e,w=Ve(d,c,e)*d%e,S=Ve(w,a,e)*g%e,y=Ve(S,t,e)*l%e,I=Ve(y,i,e)*b%e,R=Ve(I,n,e)*u%e,T=Ve(R,Vi,e);if(!Gi.eql(Gi.sqr(T),r))throw new Error("Cannot find square root");return T}const Gi=Po(vf,void 0,void 0,{sqrt:My}),Fo=Dy({a:BigInt(0),b:BigInt(7),Fp:Gi,n:Vc,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Vc,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Fy*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=Gc(o*r,e),c=Gc(-n*r,e);let u=De(r-a*t-c*s,e),l=De(-a*n-c*o,e);const f=u>i,h=l>i;if(f&&(u=e-u),h&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:f,k1:u,k2neg:h,k2:l}}}},Ty);BigInt(0);Fo.ProjectivePoint;const Hy=Jr.utils.randomPrivateKey,Yc=()=>{const r=Jr.utils.randomPrivateKey(),e=yo(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},yo=Jr.getPublicKey;function Zc(r){try{return Jr.ExtendedPoint.fromHex(r),!0}catch{return!1}}const qa=(r,e)=>Jr.sign(r,e.slice(0,32)),Ky=Jr.verify,de=r=>O.Buffer.isBuffer(r)?r:r instanceof Uint8Array?O.Buffer.from(r.buffer,r.byteOffset,r.byteLength):O.Buffer.from(r);class ja{constructor(e){Object.assign(this,e)}encode(){return O.Buffer.from(Kl(gs,this))}static decode(e){return Wl(gs,this,e)}static decodeUnchecked(e){return zl(gs,this,e)}}class Wy extends ja{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const gs=new Map;var Af;const Bf=32,ln=32;function qy(r){return r._bn!==void 0}let Xc=1;class K extends ja{constructor(e){if(super({}),this._bn=void 0,qy(e))this._bn=e._bn;else{if(typeof e=="string"){const t=ht.decode(e);if(t.length!=ln)throw new Error("Invalid public key input");this._bn=new oc(t)}else this._bn=new oc(e);if(this._bn.byteLength()>ln)throw new Error("Invalid public key input")}}static unique(){const e=new K(Xc);return Xc+=1,new K(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ht.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(O.Buffer);if(e.length===ln)return e;const t=O.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=O.Buffer.concat([e.toBuffer(),O.Buffer.from(t),n.toBuffer()]),o=zc(s);return new K(o)}static createProgramAddressSync(e,t){let n=O.Buffer.alloc(0);e.forEach(function(o){if(o.length>Bf)throw new TypeError("Max seed length exceeded");n=O.Buffer.concat([n,de(o)])}),n=O.Buffer.concat([n,t.toBuffer(),O.Buffer.from("ProgramDerivedAddress")]);const s=zc(n);if(Zc(s))throw new Error("Invalid seeds, address must fall off the curve");return new K(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(O.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new K(e);return Zc(t.toBytes())}}Af=K;K.default=new Af("11111111111111111111111111111111");gs.set(K,{kind:"struct",fields:[["_bn","u256"]]});class jy{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=de(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=de(Hy()),this._publicKey=de(yo(this._secretKey))}get publicKey(){return new K(this._publicKey)}get secretKey(){return O.Buffer.concat([this._secretKey,this._publicKey],64)}}const Vy=new K("BPFLoader1111111111111111111111111111111111"),jn=1232,Mo=127,xs=64;class Va extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Va.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Ga extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ga.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Tr extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Tr.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Es{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const we=(r="publicKey")=>Ne(32,r),Gy=(r="signature")=>Ne(64,r),nr=(r="string")=>{const e=te([ee("length"),ee("lengthPadding"),Ne(qn(ee(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:O.Buffer.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>ee().span+ee().span+O.Buffer.from(o,"utf8").length,s},Yy=(r="authorized")=>te([we("staker"),we("withdrawer")],r),Zy=(r="lockup")=>te([Ct("unixTimestamp"),Ct("epoch"),we("custodian")],r),Xy=(r="voteInit")=>te([we("nodePubkey"),we("authorizedVoter"),we("authorizedWithdrawer"),Se("commission")],r),Jy=(r="voteAuthorizeWithSeedArgs")=>te([ee("voteAuthorizationType"),we("currentAuthorityDerivedKeyOwnerPubkey"),nr("currentAuthorityDerivedKeySeed"),we("newAuthorized")],r);function _f(r,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return _f({layout:s},e[s.property]);return 0};let n=0;return r.layout.fields.forEach(s=>{n+=t(s)}),n}function Rt(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Ot(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function xe(r,e){if(!r)throw new Error(e||"Assertion failed")}class Ho{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Ho(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];xe(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{xe(t.length>0,"Expected at least one writable signer key");const[c]=t[0];xe(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new K(c)),...n.map(([c])=>new K(c)),...s.map(([c])=>new K(c)),...o.map(([c])=>new K(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new K(o),c=e.findIndex(u=>u.equals(a));c>=0&&(xe(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}const Rf="Reached end of buffer unexpectedly";function an(r){if(r.length===0)throw new Error(Rf);return r.shift()}function Lt(r,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>r.length:t>=r.length)throw new Error(Rf);return r.splice(...e)}class Qt{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new K(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ht.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Es(this.staticAccountKeys)}static compile(e){const t=Ho.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new Es(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:ht.encode(a.data)}));return new Qt({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ot(t,e);const n=this.instructions.map(f=>{const{accounts:h,programIdIndex:p}=f,b=Array.from(ht.decode(f.data));let g=[];Ot(g,h.length);let d=[];return Ot(d,b.length),{programIdIndex:p,keyIndicesCount:O.Buffer.from(g),keyIndices:h,dataLength:O.Buffer.from(d),data:b}});let s=[];Ot(s,n.length);let o=O.Buffer.alloc(jn);O.Buffer.from(s).copy(o);let i=s.length;n.forEach(f=>{const p=te([Se("programIdIndex"),Ne(f.keyIndicesCount.length,"keyIndicesCount"),pt(Se("keyIndex"),f.keyIndices.length,"keyIndices"),Ne(f.dataLength.length,"dataLength"),pt(Se("userdatum"),f.data.length,"data")]).encode(f,o,i);i+=p}),o=o.slice(0,i);const a=te([Ne(1,"numRequiredSignatures"),Ne(1,"numReadonlySignedAccounts"),Ne(1,"numReadonlyUnsignedAccounts"),Ne(t.length,"keyCount"),pt(we("key"),e,"keys"),we("recentBlockhash")]),c={numRequiredSignatures:O.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:O.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:O.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:O.Buffer.from(t),keys:this.accountKeys.map(f=>de(f.toBytes())),recentBlockhash:ht.decode(this.recentBlockhash)};let u=O.Buffer.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const n=an(t);if(n!==(n&Mo))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=an(t),o=an(t),i=Rt(t);let a=[];for(let h=0;h<i;h++){const p=Lt(t,0,ln);a.push(new K(O.Buffer.from(p)))}const c=Lt(t,0,ln),u=Rt(t);let l=[];for(let h=0;h<u;h++){const p=an(t),b=Rt(t),g=Lt(t,0,b),d=Rt(t),w=Lt(t,0,d),S=ht.encode(O.Buffer.from(w));l.push({programIdIndex:p,accounts:g,data:S})}const f={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:ht.encode(O.Buffer.from(c)),accountKeys:a,instructions:l};return new Qt(f)}}class dr{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Es(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Ho.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const f=t.extractTableLookup(l);if(f!==void 0){const[h,{writable:p,readonly:b}]=f;n.push(h),s.writable.push(...p),s.readonly.push(...b)}}const[i,a]=t.getMessageComponents(),u=new Es(a,s).compileInstructions(e.instructions);return new dr({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:n})}serialize(){const e=Array();Ot(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Ot(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Ot(o,this.addressTableLookups.length);const i=te([Se("prefix"),te([Se("numRequiredSignatures"),Se("numReadonlySignedAccounts"),Se("numReadonlyUnsignedAccounts")],"header"),Ne(e.length,"staticAccountKeysLength"),pt(we(),this.staticAccountKeys.length,"staticAccountKeys"),we("recentBlockhash"),Ne(n.length,"instructionsLength"),Ne(t.length,"serializedInstructions"),Ne(o.length,"addressTableLookupsLength"),Ne(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(jn),u=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:ht.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(jn);for(const n of this.compiledInstructions){const s=Array();Ot(s,n.accountKeyIndexes.length);const o=Array();Ot(o,n.data.length);const i=te([Se("programIdIndex"),Ne(s.length,"encodedAccountKeyIndexesLength"),pt(Se(),n.accountKeyIndexes.length,"accountKeyIndexes"),Ne(o.length,"encodedDataLength"),Ne(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(jn);for(const n of this.addressTableLookups){const s=Array();Ot(s,n.writableIndexes.length);const o=Array();Ot(o,n.readonlyIndexes.length);const i=te([we("accountKey"),Ne(s.length,"encodedWritableIndexesLength"),pt(Se(),n.writableIndexes.length,"writableIndexes"),Ne(o.length,"encodedReadonlyIndexesLength"),pt(Se(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=an(t),s=n&Mo;xe(n!==s,"Expected versioned message but received legacy message");const o=s;xe(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:an(t),numReadonlySignedAccounts:an(t),numReadonlyUnsignedAccounts:an(t)},a=[],c=Rt(t);for(let b=0;b<c;b++)a.push(new K(Lt(t,0,ln)));const u=ht.encode(Lt(t,0,ln)),l=Rt(t),f=[];for(let b=0;b<l;b++){const g=an(t),d=Rt(t),w=Lt(t,0,d),S=Rt(t),y=new Uint8Array(Lt(t,0,S));f.push({programIdIndex:g,accountKeyIndexes:w,data:y})}const h=Rt(t),p=[];for(let b=0;b<h;b++){const g=new K(Lt(t,0,ln)),d=Rt(t),w=Lt(t,0,d),S=Rt(t),y=Lt(t,0,S);p.push({accountKey:g,writableIndexes:w,readonlyIndexes:y})}return new dr({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:f,addressTableLookups:p})}}const Ya={deserializeMessageVersion(r){const e=r[0],t=e&Mo;return t===e?"legacy":t},deserialize:r=>{const e=Ya.deserializeMessageVersion(r);if(e==="legacy")return Qt.from(r);if(e===0)return dr.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let Sn=function(r){return r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID",r}({});const Qy=O.Buffer.alloc(xs).fill(0);class Pe{constructor(e){this.keys=void 0,this.programId=void 0,this.data=O.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class _e{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Pe(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let g=0;g<t.length;g++)if(t[g].programId===void 0)throw new Error(`Transaction instruction index ${g} has undefined program id`);const s=[],o=[];t.forEach(g=>{g.keys.forEach(w=>{o.push({...w})});const d=g.programId.toString();s.includes(d)||s.push(d)}),s.forEach(g=>{o.push({pubkey:new K(g),isSigner:!1,isWritable:!1})});const i=[];o.forEach(g=>{const d=g.pubkey.toString(),w=i.findIndex(S=>S.pubkey.toString()===d);w>-1?(i[w].isWritable=i[w].isWritable||g.isWritable,i[w].isSigner=i[w].isSigner||g.isSigner):i.push(g)}),i.sort(function(g,d){if(g.isSigner!==d.isSigner)return g.isSigner?-1:1;if(g.isWritable!==d.isWritable)return g.isWritable?-1:1;const w={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return g.pubkey.toBase58().localeCompare(d.pubkey.toBase58(),"en",w)});const a=i.findIndex(g=>g.pubkey.equals(n));if(a>-1){const[g]=i.splice(a,1);g.isSigner=!0,g.isWritable=!0,i.unshift(g)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const g of this.signatures){const d=i.findIndex(w=>w.pubkey.equals(g.publicKey));if(d>-1)i[d].isSigner||(i[d].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${g.publicKey.toString()}`)}let c=0,u=0,l=0;const f=[],h=[];i.forEach(({pubkey:g,isSigner:d,isWritable:w})=>{d?(f.push(g.toString()),c+=1,w||(u+=1)):(h.push(g.toString()),w||(l+=1))});const p=f.concat(h),b=t.map(g=>{const{data:d,programId:w}=g;return{programIdIndex:p.indexOf(w.toString()),accounts:g.keys.map(S=>p.indexOf(S.pubkey.toString())),data:ht.encode(d)}});return b.forEach(g=>{xe(g.programIdIndex>=0),g.accounts.forEach(d=>xe(d>=0))}),new Qt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:p,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=qa(n,s.secretKey);this._addSignature(s.publicKey,de(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){xe(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=O.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:o}of this.signatures)s===null?t&&(n.missing||(n.missing=[])).push(o):Ky(s,e,o.toBytes())||(n.invalid||(n.invalid=[])).push(o);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const o=this._getMessageSignednessErrors(s,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Ot(n,t.length);const s=n.length+t.length*64+e.length,o=O.Buffer.alloc(s);return xe(t.length<256),O.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(xe(i.length===64,"signature has invalid length"),O.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),xe(o.length<=jn,`Transaction too large: ${o.length} > ${jn}`),o}get keys(){return xe(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return xe(this.instructions.length===1),this.instructions[0].programId}get data(){return xe(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=Rt(t);let s=[];for(let o=0;o<n;o++){const i=Lt(t,0,xs);s.push(ht.encode(O.Buffer.from(i)))}return _e.populate(Qt.from(t),s)}static populate(e,t=[]){const n=new _e;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==ht.encode(Qy)?null:ht.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new Pe({keys:o,programId:e.accountKeys[s.programIdIndex],data:ht.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class Za{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:s,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,u=i-a;xe(u>0,"Message header is invalid");const l=e.staticAccountKeys.length-i-c;xe(l>=0,"Message header is invalid");const f=e.getAccountKeys(t),h=f.get(0);if(h===void 0)throw new Error("Failed to decompile message because no account keys were found");const p=[];for(const b of s){const g=[];for(const w of b.accountKeyIndexes){const S=f.get(w);if(S===void 0)throw new Error(`Failed to find key for account key index ${w}`);const y=w<i;let I;y?I=w<u:w<f.staticAccountKeys.length?I=w-i<l:I=w-f.staticAccountKeys.length<f.accountKeysFromLookups.writable.length,g.push({pubkey:S,isSigner:w<n.numRequiredSignatures,isWritable:I})}const d=f.get(b.programIdIndex);if(d===void 0)throw new Error(`Failed to find program id for program id index ${b.programIdIndex}`);p.push(new Pe({programId:d,data:de(b.data),keys:g}))}return new Za({payerKey:h,instructions:p,recentBlockhash:o})}compileToLegacyMessage(){return Qt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return dr.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Xa{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)xe(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(xs));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Ot(t,this.signatures.length);const n=te([Ne(t.length,"encodedSignaturesLength"),pt(Gy(),this.signatures.length,"signatures"),Ne(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e];const n=[],s=Rt(t);for(let i=0;i<s;i++)n.push(new Uint8Array(Lt(t,0,xs)));const o=Ya.deserialize(new Uint8Array(t));return new Xa(o,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const o=n.findIndex(i=>i.equals(s.publicKey));xe(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=qa(t,s.secretKey)}}addSignature(e,t){xe(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));xe(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}const eb=160,tb=64,nb=eb/tb,Lf=1e3/nb,on=new K("SysvarC1ock11111111111111111111111111111111"),rb=new K("SysvarEpochSchedu1e111111111111111111111111"),sb=new K("Sysvar1nstructions1111111111111111111111111"),Zs=new K("SysvarRecentB1ockHashes11111111111111111111"),Wr=new K("SysvarRent111111111111111111111111111111111"),ob=new K("SysvarRewards111111111111111111111111111111"),ib=new K("SysvarS1otHashes111111111111111111111111111"),ab=new K("SysvarS1otHistory11111111111111111111111111"),Xs=new K("SysvarStakeHistory1111111111111111111111111");class Is extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){const o=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const o=s.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}const cb={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class ne extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}async function Yi(r,e,t,n){const s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await r.sendTransaction(e,t,s);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await r.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await r.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await r.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new Is({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function er(r){return new Promise(e=>setTimeout(e,r))}function ke(r,e){const t=r.layout.span>=0?r.layout.span:_f(r,e),n=O.Buffer.alloc(t),s=Object.assign({instruction:r.index},e);return r.layout.encode(s,n),n}function Re(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.instruction!==r.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${r.index}`);return t}const Tf=lt("lamportsPerSignature"),$f=te([ee("version"),ee("state"),we("authorizedPubkey"),we("nonce"),te([Tf],"feeCalculator")]),Zi=$f.span;class Ko{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=$f.decode(de(e),0);return new Ko({authorizedPubkey:new K(t.authorizedPubkey),nonce:new K(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const ub=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},lb=r=>e=>{const t=Ne(r,e),{encode:n,decode:s}=ub(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Ag(O.Buffer.from(c))},o.encode=(i,a,c)=>{const u=uf(i,r);return n(u,a,c)},o},qr=lb(8);class fb{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=ee("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(Oe))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a SystemInstruction");return s}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:n,programId:s}=Re(Oe.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new K(s)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=Re(Oe.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:n,programId:s}=Re(Oe.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new K(s)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=Re(Oe.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,space:s,programId:o}=Re(Oe.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new K(t),seed:n,space:s,programId:new K(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=Re(Oe.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new K(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,programId:s}=Re(Oe.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new K(t),seed:n,programId:new K(s)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:n,lamports:s,space:o,programId:i}=Re(Oe.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new K(t),seed:n,lamports:s,space:o,programId:new K(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=Re(Oe.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new K(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Re(Oe.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Re(Oe.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=Re(Oe.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new K(t)}}static checkProgramId(e){if(!e.equals(st.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Oe=Object.freeze({Create:{index:0,layout:te([ee("instruction"),Ct("lamports"),Ct("space"),we("programId")])},Assign:{index:1,layout:te([ee("instruction"),we("programId")])},Transfer:{index:2,layout:te([ee("instruction"),qr("lamports")])},CreateWithSeed:{index:3,layout:te([ee("instruction"),we("base"),nr("seed"),Ct("lamports"),Ct("space"),we("programId")])},AdvanceNonceAccount:{index:4,layout:te([ee("instruction")])},WithdrawNonceAccount:{index:5,layout:te([ee("instruction"),Ct("lamports")])},InitializeNonceAccount:{index:6,layout:te([ee("instruction"),we("authorized")])},AuthorizeNonceAccount:{index:7,layout:te([ee("instruction"),we("authorized")])},Allocate:{index:8,layout:te([ee("instruction"),Ct("space")])},AllocateWithSeed:{index:9,layout:te([ee("instruction"),we("base"),nr("seed"),Ct("space"),we("programId")])},AssignWithSeed:{index:10,layout:te([ee("instruction"),we("base"),nr("seed"),we("programId")])},TransferWithSeed:{index:11,layout:te([ee("instruction"),qr("lamports"),nr("seed"),we("programId")])},UpgradeNonceAccount:{index:12,layout:te([ee("instruction")])}});class st{constructor(){}static createAccount(e){const t=Oe.Create,n=ke(t,{lamports:e.lamports,space:e.space,programId:de(e.programId.toBuffer())});return new Pe({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const s=Oe.TransferWithSeed;t=ke(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:de(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Oe.Transfer;t=ke(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new Pe({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const s=Oe.AssignWithSeed;t=ke(s,{base:de(e.basePubkey.toBuffer()),seed:e.seed,programId:de(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Oe.Assign;t=ke(s,{programId:de(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Pe({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=Oe.CreateWithSeed,n=ke(t,{base:de(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:de(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new Pe({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){const t=new _e;"basePubkey"in e&&"seed"in e?t.add(st.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Zi,programId:this.programId})):t.add(st.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Zi,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=Oe.InitializeNonceAccount,n=ke(t,{authorized:de(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Zs,isSigner:!1,isWritable:!1},{pubkey:Wr,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new Pe(s)}static nonceAdvance(e){const t=Oe.AdvanceNonceAccount,n=ke(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Zs,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new Pe(s)}static nonceWithdraw(e){const t=Oe.WithdrawNonceAccount,n=ke(t,{lamports:e.lamports});return new Pe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Zs,isSigner:!1,isWritable:!1},{pubkey:Wr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=Oe.AuthorizeNonceAccount,n=ke(t,{authorized:de(e.newAuthorizedPubkey.toBuffer())});return new Pe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const s=Oe.AllocateWithSeed;t=ke(s,{base:de(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:de(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Oe.Allocate;t=ke(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Pe({keys:n,programId:this.programId,data:t})}}st.programId=new K("11111111111111111111111111111111");const db=jn-300;class hr{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/hr.chunkSize)+1+1)}static async load(e,t,n,s,o){{const f=await e.getMinimumBalanceForRentExemption(o.length),h=await e.getAccountInfo(n.publicKey,"confirmed");let p=null;if(h!==null){if(h.executable)return console.error("Program load failed, account is already executable"),!1;h.data.length!==o.length&&(p=p||new _e,p.add(st.allocate({accountPubkey:n.publicKey,space:o.length}))),h.owner.equals(s)||(p=p||new _e,p.add(st.assign({accountPubkey:n.publicKey,programId:s}))),h.lamports<f&&(p=p||new _e,p.add(st.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:f-h.lamports})))}else p=new _e().add(st.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:f>0?f:1,space:o.length,programId:s}));p!==null&&await Yi(e,p,[t,n],{commitment:"confirmed"})}const i=te([ee("instruction"),ee("offset"),ee("bytesLength"),ee("bytesLengthPadding"),pt(Se("byte"),qn(ee(),-8),"bytes")]),a=hr.chunkSize;let c=0,u=o,l=[];for(;u.length>0;){const f=u.slice(0,a),h=O.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:f,bytesLength:0,bytesLengthPadding:0},h);const p=new _e().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:s,data:h});l.push(Yi(e,p,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await er(1e3/4),c+=a,u=u.slice(a)}await Promise.all(l);{const f=te([ee("instruction")]),h=O.Buffer.alloc(f.span);f.encode({instruction:1},h);const p=new _e().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:Wr,isSigner:!1,isWritable:!1}],programId:s,data:h}),b="processed",g=await e.sendTransaction(p,[t,n],{preflightCommitment:b}),{context:d,value:w}=await e.confirmTransaction({signature:g,lastValidBlockHeight:p.lastValidBlockHeight,blockhash:p.recentBlockhash},b);if(w.err)throw new Error(`Transaction ${g} failed (${JSON.stringify(w)})`);for(;;){try{if(await e.getSlot({commitment:b})>d.slot)break}catch{}await new Promise(S=>setTimeout(S,Math.round(Lf/2)))}}return!0}}hr.chunkSize=db;const hb=new K("BPFLoader2111111111111111111111111111111111");class pb{static getMinNumSignatures(e){return hr.getMinNumSignatures(e)}static load(e,t,n,s,o){return hr.load(e,t,n,o,s)}}function gb(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var _i,Jc;function yb(){if(Jc)return _i;Jc=1;var r=Object.prototype.toString,e=Object.keys||function(n){var s=[];for(var o in n)s.push(o);return s};function t(n,s){var o,i,a,c,u,l,f;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),s);if(f=r.call(n),f==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(f==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)u=c[o],l=t(n[u],!1),l!==void 0&&(a&&(a+=","),a+=JSON.stringify(u)+":"+l),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return _i=function(n){var s=t(n,!1);if(s!==void 0)return""+s},_i}var bb=yb(),Qc=gb(bb);const ds=32;function Ri(r){let e=0;for(;r>1;)r/=2,e++;return e}function wb(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class Pf{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Ri(wb(e+ds+1))-Ri(ds)-1,n=this.getSlotsInEpoch(t),s=e-(n-ds);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*ds:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Ri(ds)):this.slotsPerEpoch}}var mb=globalThis.fetch;class kb extends hy{constructor(e,t,n){const s=o=>{const i=fy(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Sb(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const eu=56;class Xi{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Sb(xb,e),n=e.length-eu;xe(n>=0,"lookup table is invalid"),xe(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=te([pt(we(),s,"addresses")]).decode(e.slice(eu));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new K(t.authority[0]):void 0,addresses:o.map(i=>new K(i))}}}const xb={index:1,layout:te([ee("typeIndex"),qr("deactivationSlot"),lt("lastExtendedSlot"),Se("lastExtendedStartIndex"),Se(),pt(we(),qn(Se(),-1),"authority")])},Eb=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Ib(r){const e=r.match(Eb);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const qe=Ns(Ha(K),M(),r=>new K(r)),Cf=Ka([M(),He("base64")]),Ja=Ns(Ha(O.Buffer),Cf,r=>O.Buffer.from(r[0],"base64")),Of=30*1e3;function vb(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function Ce(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function tu(r){return r.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function Uf(r){return At([z({jsonrpc:He("2.0"),id:M(),result:r}),z({jsonrpc:He("2.0"),id:M(),error:z({code:ts(),message:M(),data:ce(Og())})})])}const Ab=Uf(ts());function fe(r){return Ns(Uf(r),Ab,e=>"error"in e?e:{...e,result:W(e.result,r)})}function Ge(r){return fe(z({context:z({slot:E()}),value:r}))}function Wo(r){return z({context:z({slot:E()}),value:r})}function Li(r,e){return r===0?new dr({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new K(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ht.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new Qt(e)}const Bb=z({foundation:E(),foundationTerm:E(),initial:E(),taper:E(),terminal:E()}),_b=fe(q(j(z({epoch:E(),effectiveSlot:E(),amount:E(),postBalance:E(),commission:ce(j(E()))})))),Rb=q(z({slot:E(),prioritizationFee:E()})),Lb=z({total:E(),validator:E(),foundation:E(),epoch:E()}),Tb=z({epoch:E(),slotIndex:E(),slotsInEpoch:E(),absoluteSlot:E(),blockHeight:ce(E()),transactionCount:ce(E())}),$b=z({slotsPerEpoch:E(),leaderScheduleSlotOffset:E(),warmup:dn(),firstNormalEpoch:E(),firstNormalSlot:E()}),Pb=df(M(),q(E())),kr=j(At([z({}),M()])),Cb=z({err:kr}),Ob=He("receivedSignature"),Ub=z({"solana-core":M(),"feature-set":ce(E())}),Nb=z({program:M(),programId:qe,parsed:ts()}),zb=z({programId:qe,accounts:q(qe),data:M()}),nu=Ge(z({err:j(At([z({}),M()])),logs:j(q(M())),accounts:ce(j(q(j(z({executable:dn(),owner:M(),lamports:E(),data:q(M()),rentEpoch:ce(E())}))))),unitsConsumed:ce(E()),returnData:ce(j(z({programId:M(),data:Ka([M(),He("base64")])}))),innerInstructions:ce(j(q(z({index:E(),instructions:q(At([Nb,zb]))}))))})),Db=Ge(z({byIdentity:df(M(),q(E())),range:z({firstSlot:E(),lastSlot:E()})}));function Fb(r,e,t,n,s,o){const i=t||mb;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(l,f)=>{const h=await new Promise((p,b)=>{try{n(l,f,(g,d)=>p([g,d]))}catch(g){b(g)}});return await i(...h)}),new cy(async(l,f)=>{const h={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Mw)};try{let p=5,b,g=500;for(;c?b=await c(r,h):b=await i(r,h),!(b.status!==429||s===!0||(p-=1,p===0));)console.error(`Server responded with ${b.status} ${b.statusText}.  Retrying after ${g}ms delay...`),await er(g),g*=2;const d=await b.text();b.ok?f(null,d):f(new Error(`${b.status} ${b.statusText}: ${d}`))}catch(p){p instanceof Error&&f(p)}},{})}function Mb(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function Hb(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const Kb=fe(Bb),Wb=fe(Lb),qb=fe(Rb),jb=fe(Tb),Vb=fe($b),Gb=fe(Pb),Yb=fe(E()),Zb=Ge(z({total:E(),circulating:E(),nonCirculating:E(),nonCirculatingAccounts:q(qe)})),Ji=z({amount:M(),uiAmount:j(E()),decimals:E(),uiAmountString:ce(M())}),Xb=Ge(q(z({address:qe,amount:M(),uiAmount:j(E()),decimals:E(),uiAmountString:ce(M())}))),Jb=Ge(q(z({pubkey:qe,account:z({executable:dn(),owner:qe,lamports:E(),data:Ja,rentEpoch:E()})}))),Qi=z({program:M(),parsed:ts(),space:E()}),Qb=Ge(q(z({pubkey:qe,account:z({executable:dn(),owner:qe,lamports:E(),data:Qi,rentEpoch:E()})}))),ew=Ge(q(z({lamports:E(),address:qe}))),vs=z({executable:dn(),owner:qe,lamports:E(),data:Ja,rentEpoch:E()}),tw=z({pubkey:qe,account:vs}),nw=Ns(At([Ha(O.Buffer),Qi]),At([Cf,Qi]),r=>Array.isArray(r)?W(r,Ja):r),ea=z({executable:dn(),owner:qe,lamports:E(),data:nw,rentEpoch:E()}),rw=z({pubkey:qe,account:ea}),sw=z({state:At([He("active"),He("inactive"),He("activating"),He("deactivating")]),active:E(),inactive:E()}),ow=fe(q(z({signature:M(),slot:E(),err:kr,memo:j(M()),blockTime:ce(j(E()))}))),iw=fe(q(z({signature:M(),slot:E(),err:kr,memo:j(M()),blockTime:ce(j(E()))}))),aw=z({subscription:E(),result:Wo(vs)}),cw=z({pubkey:qe,account:vs}),uw=z({subscription:E(),result:Wo(cw)}),lw=z({parent:E(),slot:E(),root:E()}),fw=z({subscription:E(),result:lw}),dw=At([z({type:At([He("firstShredReceived"),He("completed"),He("optimisticConfirmation"),He("root")]),slot:E(),timestamp:E()}),z({type:He("createdBank"),parent:E(),slot:E(),timestamp:E()}),z({type:He("frozen"),slot:E(),timestamp:E(),stats:z({numTransactionEntries:E(),numSuccessfulTransactions:E(),numFailedTransactions:E(),maxTransactionsPerEntry:E()})}),z({type:He("dead"),slot:E(),timestamp:E(),err:M()})]),hw=z({subscription:E(),result:dw}),pw=z({subscription:E(),result:Wo(At([Cb,Ob]))}),gw=z({subscription:E(),result:E()}),yw=z({pubkey:M(),gossip:j(M()),tpu:j(M()),rpc:j(M()),version:j(M())}),ru=z({votePubkey:M(),nodePubkey:M(),activatedStake:E(),epochVoteAccount:dn(),epochCredits:q(Ka([E(),E(),E()])),commission:E(),lastVote:E(),rootSlot:j(E())}),bw=fe(z({current:q(ru),delinquent:q(ru)})),ww=At([He("processed"),He("confirmed"),He("finalized")]),mw=z({slot:E(),confirmations:j(E()),err:kr,confirmationStatus:ce(ww)}),kw=Ge(q(j(mw))),Sw=fe(E()),Nf=z({accountKey:qe,writableIndexes:q(E()),readonlyIndexes:q(E())}),Qa=z({signatures:q(M()),message:z({accountKeys:q(M()),header:z({numRequiredSignatures:E(),numReadonlySignedAccounts:E(),numReadonlyUnsignedAccounts:E()}),instructions:q(z({accounts:q(E()),data:M(),programIdIndex:E()})),recentBlockhash:M(),addressTableLookups:ce(q(Nf))})}),zf=z({pubkey:qe,signer:dn(),writable:dn(),source:ce(At([He("transaction"),He("lookupTable")]))}),Df=z({accountKeys:q(zf),signatures:q(M())}),Ff=z({parsed:ts(),program:M(),programId:qe}),Mf=z({accounts:q(qe),data:M(),programId:qe}),xw=At([Mf,Ff]),Ew=At([z({parsed:ts(),program:M(),programId:M()}),z({accounts:q(M()),data:M(),programId:M()})]),Hf=Ns(xw,Ew,r=>"accounts"in r?W(r,Mf):W(r,Ff)),Kf=z({signatures:q(M()),message:z({accountKeys:q(zf),instructions:q(Hf),recentBlockhash:M(),addressTableLookups:ce(j(q(Nf)))})}),bo=z({accountIndex:E(),mint:M(),owner:ce(M()),uiTokenAmount:Ji}),Wf=z({writable:q(qe),readonly:q(qe)}),qo=z({err:kr,fee:E(),innerInstructions:ce(j(q(z({index:E(),instructions:q(z({accounts:q(E()),data:M(),programIdIndex:E()}))})))),preBalances:q(E()),postBalances:q(E()),logMessages:ce(j(q(M()))),preTokenBalances:ce(j(q(bo))),postTokenBalances:ce(j(q(bo))),loadedAddresses:ce(Wf),computeUnitsConsumed:ce(E())}),ec=z({err:kr,fee:E(),innerInstructions:ce(j(q(z({index:E(),instructions:q(Hf)})))),preBalances:q(E()),postBalances:q(E()),logMessages:ce(j(q(M()))),preTokenBalances:ce(j(q(bo))),postTokenBalances:ce(j(q(bo))),loadedAddresses:ce(Wf),computeUnitsConsumed:ce(E())}),ns=At([He(0),He("legacy")]),Sr=z({pubkey:M(),lamports:E(),postBalance:j(E()),rewardType:j(M()),commission:ce(j(E()))}),Iw=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),transactions:q(z({transaction:Qa,meta:j(qo),version:ce(ns)})),rewards:ce(q(Sr)),blockTime:j(E()),blockHeight:j(E())}))),vw=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),rewards:ce(q(Sr)),blockTime:j(E()),blockHeight:j(E())}))),Aw=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),transactions:q(z({transaction:Df,meta:j(qo),version:ce(ns)})),rewards:ce(q(Sr)),blockTime:j(E()),blockHeight:j(E())}))),Bw=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),transactions:q(z({transaction:Kf,meta:j(ec),version:ce(ns)})),rewards:ce(q(Sr)),blockTime:j(E()),blockHeight:j(E())}))),_w=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),transactions:q(z({transaction:Df,meta:j(ec),version:ce(ns)})),rewards:ce(q(Sr)),blockTime:j(E()),blockHeight:j(E())}))),Rw=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),rewards:ce(q(Sr)),blockTime:j(E()),blockHeight:j(E())}))),Lw=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),transactions:q(z({transaction:Qa,meta:j(qo)})),rewards:ce(q(Sr)),blockTime:j(E())}))),su=fe(j(z({blockhash:M(),previousBlockhash:M(),parentSlot:E(),signatures:q(M()),blockTime:j(E())}))),Ti=fe(j(z({slot:E(),meta:j(qo),blockTime:ce(j(E())),transaction:Qa,version:ce(ns)}))),Gs=fe(j(z({slot:E(),transaction:Kf,meta:j(ec),blockTime:ce(j(E())),version:ce(ns)}))),Tw=Ge(z({blockhash:M(),feeCalculator:z({lamportsPerSignature:E()})})),$w=Ge(z({blockhash:M(),lastValidBlockHeight:E()})),Pw=Ge(dn()),Cw=z({slot:E(),numTransactions:E(),numSlots:E(),samplePeriodSecs:E()}),Ow=fe(q(Cw)),Uw=Ge(j(z({feeCalculator:z({lamportsPerSignature:E()})}))),Nw=fe(M()),zw=fe(M()),Dw=z({err:kr,logs:q(M()),signature:M()}),Fw=z({result:Wo(Dw),subscription:E()}),Mw={"solana-client":"js/1.0.0-maintenance"};class Hw{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:f,config:h}=Ce(l),p=this._buildArgs([],f,void 0,h),b=Qc(p);return u[b]=u[b]??(async()=>{try{const g=await this._rpcRequest("getBlockHeight",p),d=W(g,fe(E()));if("error"in d)throw new ne(d.error,"failed to get block height information");return d.result}finally{delete u[b]}})(),await u[b]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=vb(e),this._rpcWsEndpoint=n||Ib(e),this._rpcClient=Fb(e,s,o,i,a,c),this._rpcRequest=Mb(this._rpcClient),this._rpcBatchRequest=Hb(this._rpcClient),this._rpcWebSocket=new kb(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=W(i,Ge(E()));if("error"in a)throw new ne(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=W(t,fe(j(E())));if("error"in n)throw new ne(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=W(e,fe(E()));if("error"in t)throw new ne(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=W(e,Yb);if("error"in t)throw new ne(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=W(n,Zb);if("error"in s)throw new ne(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=W(s,Ge(Ji));if("error"in o)throw new ne(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=W(s,Ge(Ji));if("error"in o)throw new ne(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=Ce(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=W(c,Jb);if("error"in u)throw new ne(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=W(i,Qb);if("error"in a)throw new ne(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=W(s,ew);if("error"in o)throw new ne(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=W(s,Xb);if("error"in o)throw new ne(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=W(i,Ge(j(vs)));if("error"in a)throw new ne(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=W(i,Ge(j(ea)));if("error"in a)throw new ne(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=Ce(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=W(a,Ge(q(j(ea))));if("error"in c)throw new ne(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=Ce(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=W(a,Ge(q(j(vs))));if("error"in c)throw new ne(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=Ce(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=W(a,fe(sw));if("error"in c)throw new ne(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=Ce(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",{...i,...i.filters?{filters:tu(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),u=q(tw),l=i.withContext===!0?W(c,Ge(u)):W(c,fe(u));if("error"in l)throw new ne(l.error,`failed to get accounts owned by program ${e.toBase58()}`);return l.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=W(i,fe(q(rw)));if("error"in a)throw new ne(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let n;if(typeof e=="string")n=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);n=i.signature}let s;try{s=ht.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return xe(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,u)=>{try{n=this.onSignature(t,(f,h)=>{n=void 0;const p={context:h,value:f};c({__type:Sn.PROCESSED,response:p})},e);const l=new Promise(f=>{n==null?f():s=this._onSubscriptionStateChange(n,h=>{h==="subscribed"&&f()})});(async()=>{if(await l,o)return;const f=await this.getSignatureStatus(t);if(o||f==null)return;const{context:h,value:p}=f;if(p!=null)if(p!=null&&p.err)u(p.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(p.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(p.confirmationStatus==="processed"||p.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Sn.PROCESSED,response:{context:h,value:p}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(f=>{const h=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let p=await h();if(!o){for(;p<=n;)if(await er(1e3),o||(p=await h(),o))return;f({__type:Sn.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let l;try{const f=await Promise.race([u,c,i]);if(f.__type===Sn.PROCESSED)l=f.response;else throw new Va(s)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(p=>{let b=o,g=null;const d=async()=>{try{const{context:w,value:S}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return g=w.slot,S==null?void 0:S.nonce}catch{return b}};(async()=>{if(b=await d(),!a)for(;;){if(o!==b){p({__type:Sn.NONCE_INVALID,slotInWhichNonceDidAdvance:g});return}if(await er(2e3),a||(b=await d(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),f=this.getCancellationPromise(t);let h;try{const p=await Promise.race([f,l,c]);if(p.__type===Sn.PROCESSED)h=p.response;else{let b;for(;;){const g=await this.getSignatureStatus(i);if(g==null)break;if(g.context.slot<(p.slotInWhichNonceDidAdvance??n)){await er(400);continue}b=g;break}if(b!=null&&b.value){const g=e||"finalized",{confirmationStatus:d}=b.value;switch(g){case"processed":case"recent":if(d!=="processed"&&d!=="confirmed"&&d!=="finalized")throw new Tr(i);break;case"confirmed":case"single":case"singleGossip":if(d!=="confirmed"&&d!=="finalized")throw new Tr(i);break;case"finalized":case"max":case"root":if(d!=="finalized")throw new Tr(i);break;default:}h={context:b.context,value:{err:b.value.err}}}else throw new Tr(i)}}finally{a=!0,u()}return h}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:Sn.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===Sn.PROCESSED)a=c.response;else throw new Ga(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=W(e,fe(q(yw)));if("error"in t)throw new ne(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=W(n,bw);if("error"in s)throw new ne(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=Ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=W(o,fe(E()));if("error"in i)throw new ne(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=Ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=W(o,fe(M()));if("error"in i)throw new ne(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=W(s,fe(q(qe)));if("error"in o)throw new ne(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);xe(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=W(s,kw);if("error"in o)throw new ne(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=Ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=W(o,fe(E()));if("error"in i)throw new ne(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=W(n,Kb);if("error"in s)throw new ne(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=Ce(n),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=W(a,_b);if("error"in c)throw new ne(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=W(e,Wb);if("error"in t)throw new ne(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=Ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=W(o,jb);if("error"in i)throw new ne(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=W(e,Vb);if("error"in t)throw new ne(t.error,"failed to get epoch schedule");const n=t.result;return new Pf(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=W(e,Gb);if("error"in t)throw new ne(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=W(s,Sw);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=W(n,Tw);if("error"in s)throw new ne(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=W(t,Ow);if("error"in n)throw new ne(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=W(s,Uw);if("error"in o)throw new ne(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=de(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=W(o,Ge(j(E())));if("error"in i)throw new ne(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),o=W(s,qb);if("error"in o)throw new ne(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=Ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=W(o,$w);if("error"in i)throw new ne(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgs([e],n,void 0,s),i=await this._rpcRequest("isBlockhashValid",o),a=W(i,Pw);if("error"in a)throw new ne(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=W(e,fe(Ub));if("error"in t)throw new ne(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=W(e,fe(M()));if("error"in t)throw new ne(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=W(i,Aw);if("error"in a)throw a.error;return a.result}case"none":{const a=W(i,vw);if("error"in a)throw a.error;return a.result}default:{const a=W(i,Iw);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:f})=>({meta:l,transaction:{...u,message:Li(f,u.message)},version:f}))}:null}}}catch(a){throw new ne(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=W(i,_w);if("error"in a)throw a.error;return a.result}case"none":{const a=W(i,Rw);if("error"in a)throw a.error;return a.result}default:{const a=W(i,Bw);if("error"in a)throw a.error;return a.result}}}catch(a){throw new ne(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=W(o,Db);if("error"in i)throw new ne(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=W(i,Ti);if("error"in a)throw new ne(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Li(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=Ce(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=W(i,Gs);if("error"in a)throw new ne(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=Ce(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=W(c,Gs);if("error"in u)throw new ne(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:n,config:s}=Ce(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=W(c,Ti);if("error"in u)throw new ne(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:Li(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),o=W(s,Lw);if("error"in o)throw new ne(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new Qt(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:_e.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=W(o,fe(q(E())));if("error"in i)throw new ne(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=W(s,su);if("error"in o)throw new ne(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),o=W(s,su);if("error"in o)throw new ne(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),o=W(s,Ti);if("error"in o)throw new ne(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new Qt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:_e.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),o=W(s,Gs);if("error"in o)throw new ne(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=W(i,Gs);if("error"in a)throw new ne(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=W(o,ow);if("error"in i)throw new ne(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=W(o,iw);if("error"in i)throw new ne(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new Xi({key:e,state:Xi.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=Ko.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=W(n,Nw);if("error"in s)throw new ne(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await er(100);const n=Date.now()-this._blockhashInfo.lastFetch>=Of;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await er(Lf/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=Ce(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=W(o,Ge(E()));if("error"in i)throw new ne(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const g=e.serialize(),d=O.Buffer.from(g).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const w=t||{};w.encoding="base64","commitment"in w||(w.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(w.innerInstructions=t.innerInstructions);const S=[d,w],y=await this._rpcRequest("simulateTransaction",S),I=W(y,nu);if("error"in I)throw new Error("failed to simulate transaction: "+I.error.message);return I.result}let s;if(e instanceof _e){let b=e;s=new _e,s.feePayer=b.feePayer,s.instructions=e.instructions,s.nonceInfo=b.nonceInfo,s.signatures=b.signatures}else s=_e.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let b=this._disableBlockhashCaching;for(;;){const g=await this._blockhashWithExpiryBlockHeight(b);if(s.lastValidBlockHeight=g.lastValidBlockHeight,s.recentBlockhash=g.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const d=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(d)&&!this._blockhashInfo.transactionSignatures.includes(d)){this._blockhashInfo.simulatedSignatures.push(d);break}else b=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const b=(Array.isArray(n)?n:i.nonProgramIds()).map(g=>g.toBase58());l.accounts={encoding:"base64",addresses:b}}o&&(l.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(l.innerInstructions=t.innerInstructions);const f=[u,l],h=await this._rpcRequest("simulateTransaction",f),p=W(h,nu);if("error"in p){let b;if("data"in p.error&&(b=p.error.data.logs,b&&Array.isArray(b))){const g=`
    `,d=g+b.join(g);console.error(p.error.message,d)}throw new Is({action:"simulate",signature:"",transactionMessage:p.error.message,logs:b})}return p.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=de(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=W(a,zw);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new Is({action:s?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:u})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=W(e,aw);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=Qc([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];xe(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:s,config:o}=Ce(n),i=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=W(e,uw);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const{commitment:o,config:i}=Ce(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(s?{filters:tu(s)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=W(e,Fw);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=W(e,fw);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=W(e,hw);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=W(e,pw);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=W(e,gw);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Cr{constructor(e){this._keypair=void 0,this._keypair=e??Yc()}static generate(){return new Cr(Yc())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),o=yo(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Cr({publicKey:n,secretKey:e})}static fromSeed(e){const t=yo(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Cr({publicKey:t,secretKey:n})}get publicKey(){return new K(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const _n=Object.freeze({CreateLookupTable:{index:0,layout:te([ee("instruction"),qr("recentSlot"),Se("bumpSeed")])},FreezeLookupTable:{index:1,layout:te([ee("instruction")])},ExtendLookupTable:{index:2,layout:te([ee("instruction"),qr(),pt(we(),qn(ee(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:te([ee("instruction")])},CloseLookupTable:{index:4,layout:te([ee("instruction")])}});class Kw{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=ee("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(_n))if(i.index==n){s=o;break}if(!s)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return s}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=Re(_n.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=Re(_n.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(n=>new K(n))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(tc.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class tc{constructor(){}static createLookupTable(e){const[t,n]=K.findProgramAddressSync([e.authority.toBuffer(),uf(BigInt(e.recentSlot),8)],this.programId),s=_n.CreateLookupTable,o=ke(s,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:st.programId,isSigner:!1,isWritable:!1}];return[new Pe({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){const t=_n.FreezeLookupTable,n=ke(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Pe({programId:this.programId,keys:s,data:n})}static extendLookupTable(e){const t=_n.ExtendLookupTable,n=ke(t,{addresses:e.addresses.map(o=>o.toBytes())}),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&s.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:st.programId,isSigner:!1,isWritable:!1}),new Pe({programId:this.programId,keys:s,data:n})}static deactivateLookupTable(e){const t=_n.DeactivateLookupTable,n=ke(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Pe({programId:this.programId,keys:s,data:n})}static closeLookupTable(e){const t=_n.CloseLookupTable,n=ke(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new Pe({programId:this.programId,keys:s,data:n})}}tc.programId=new K("AddressLookupTab1e1111111111111111111111111");class Ww{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=Se("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(cn))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return s}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:n}=Re(cn.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=Re(cn.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=Re(cn.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=Re(cn.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(nc.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const cn=Object.freeze({RequestUnits:{index:0,layout:te([Se("instruction"),ee("units"),ee("additionalFee")])},RequestHeapFrame:{index:1,layout:te([Se("instruction"),ee("bytes")])},SetComputeUnitLimit:{index:2,layout:te([Se("instruction"),ee("units")])},SetComputeUnitPrice:{index:3,layout:te([Se("instruction"),qr("microLamports")])}});class nc{constructor(){}static requestUnits(e){const t=cn.RequestUnits,n=ke(t,e);return new Pe({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=cn.RequestHeapFrame,n=ke(t,e);return new Pe({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=cn.SetComputeUnitLimit,n=ke(t,e);return new Pe({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=cn.SetComputeUnitPrice,n=ke(t,{microLamports:BigInt(e.microLamports)});return new Pe({keys:[],programId:this.programId,data:n})}}nc.programId=new K("ComputeBudget111111111111111111111111111111");const ou=64,iu=32,au=64,cu=te([Se("numSignatures"),Se("padding"),Dt("signatureOffset"),Dt("signatureInstructionIndex"),Dt("publicKeyOffset"),Dt("publicKeyInstructionIndex"),Dt("messageDataOffset"),Dt("messageDataSize"),Dt("messageInstructionIndex")]);class jo{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:s,instructionIndex:o}=e;xe(t.length===iu,`Public Key must be ${iu} bytes but received ${t.length} bytes`),xe(s.length===au,`Signature must be ${au} bytes but received ${s.length} bytes`);const i=cu.span,a=i+t.length,c=a+s.length,u=1,l=O.Buffer.alloc(c+n.length),f=o??65535;return cu.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:f,publicKeyOffset:i,publicKeyInstructionIndex:f,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:f},l),l.fill(t,i),l.fill(s,a),l.fill(n,c),new Pe({keys:[],programId:jo.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:s}=e;xe(t.length===ou,`Private key must be ${ou} bytes but received ${t.length} bytes`);try{const o=Cr.fromSecretKey(t),i=o.publicKey.toBytes(),a=qa(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}jo.programId=new K("Ed25519SigVerify111111111111111111111111111");const qw=(r,e)=>{const t=Fo.sign(r,e);return[t.toCompactRawBytes(),t.recovery]};Fo.utils.isValidPrivateKey;const jw=Fo.getPublicKey,uu=32,$i=20,lu=64,Vw=11,Pi=te([Se("numSignatures"),Dt("signatureOffset"),Se("signatureInstructionIndex"),Dt("ethAddressOffset"),Se("ethAddressInstructionIndex"),Dt("messageDataOffset"),Dt("messageDataSize"),Se("messageInstructionIndex"),Ne(20,"ethAddress"),Ne(64,"signature"),Se("recoveryId")]);class Or{constructor(){}static publicKeyToEthAddress(e){xe(e.length===lu,`Public key must be ${lu} bytes but received ${e.length} bytes`);try{return O.Buffer.from(Wc(de(e))).slice(-$i)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:s,recoveryId:o,instructionIndex:i}=e;return Or.createInstructionWithEthAddress({ethAddress:Or.publicKeyToEthAddress(t),message:n,signature:s,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:n,signature:s,recoveryId:o,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=O.Buffer.from(t.substr(2),"hex"):a=O.Buffer.from(t,"hex"):a=t,xe(a.length===$i,`Address must be ${$i} bytes but received ${a.length} bytes`);const c=1+Vw,u=c,l=c+a.length,f=l+s.length+1,h=1,p=O.Buffer.alloc(Pi.span+n.length);return Pi.encode({numSignatures:h,signatureOffset:l,signatureInstructionIndex:i,ethAddressOffset:u,ethAddressInstructionIndex:i,messageDataOffset:f,messageDataSize:n.length,messageInstructionIndex:i,signature:de(s),ethAddress:de(a),recoveryId:o},p),p.fill(de(n),Pi.span),new Pe({keys:[],programId:Or.programId,data:p})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:s}=e;xe(t.length===uu,`Private key must be ${uu} bytes but received ${t.length} bytes`);try{const o=de(t),i=jw(o,!1).slice(1),a=O.Buffer.from(Wc(de(n))),[c,u]=qw(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:u,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}Or.programId=new K("KeccakSecp256k11111111111111111111111111111");var qf;const jf=new K("StakeConfig11111111111111111111111111111111");class Vf{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class zs{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}qf=zs;zs.default=new qf(0,0,K.default);class Gw{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=ee("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(rt))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a StakeInstruction");return s}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:n}=Re(rt.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Vf(new K(t.staker),new K(t.withdrawer)),lockup:new zs(n.unixTimestamp,n.epoch,new K(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),Re(rt.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:n}=Re(rt.Authorize,e.data),s={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new K(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:s,authorityOwner:o}=Re(rt.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:s,authorityOwner:new K(o),newAuthorizedPubkey:new K(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Re(rt.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Re(rt.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=Re(rt.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),Re(rt.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Vo.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const rt=Object.freeze({Initialize:{index:0,layout:te([ee("instruction"),Yy(),Zy()])},Authorize:{index:1,layout:te([ee("instruction"),we("newAuthorized"),ee("stakeAuthorizationType")])},Delegate:{index:2,layout:te([ee("instruction")])},Split:{index:3,layout:te([ee("instruction"),Ct("lamports")])},Withdraw:{index:4,layout:te([ee("instruction"),Ct("lamports")])},Deactivate:{index:5,layout:te([ee("instruction")])},Merge:{index:7,layout:te([ee("instruction")])},AuthorizeWithSeed:{index:8,layout:te([ee("instruction"),we("newAuthorized"),ee("stakeAuthorizationType"),nr("authoritySeed"),we("authorityOwner")])}}),Yw=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Vo{constructor(){}static initialize(e){const{stakePubkey:t,authorized:n,lockup:s}=e,o=s||zs.default,i=rt.Initialize,a=ke(i,{authorized:{staker:de(n.staker.toBuffer()),withdrawer:de(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:de(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Wr,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new Pe(c)}static createAccountWithSeed(e){const t=new _e;t.add(st.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static createAccount(e){const t=new _e;t.add(st.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:n,votePubkey:s}=e,o=rt.Delegate,i=ke(o);return new _e().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:Xs,isSigner:!1,isWritable:!1},{pubkey:jf,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:i}=e,a=rt.Authorize,c=ke(a,{newAuthorized:de(s.toBuffer()),stakeAuthorizationType:o.index}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:on,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&u.push({pubkey:i,isSigner:!0,isWritable:!1}),new _e().add({keys:u,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:n,authoritySeed:s,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,u=rt.AuthorizeWithSeed,l=ke(u,{newAuthorized:de(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:s,authorityOwner:de(o.toBuffer())}),f=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:on,isSigner:!1,isWritable:!1}];return c&&f.push({pubkey:c,isSigner:!0,isWritable:!1}),new _e().add({keys:f,programId:this.programId,data:l})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:s,lamports:o}=e,i=rt.Split,a=ke(i,{lamports:o});return new Pe({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){const n=new _e;return n.add(st.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,u=new _e;return u.add(st.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&u.add(st.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),u.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:s}=e,o=rt.Merge,i=ke(o);return new _e().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:Xs,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:n,toPubkey:s,lamports:o,custodianPubkey:i}=e,a=rt.Withdraw,c=ke(a,{lamports:o}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:Xs,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&u.push({pubkey:i,isSigner:!0,isWritable:!1}),new _e().add({keys:u,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:n}=e,s=rt.Deactivate,o=ke(s);return new _e().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}}Vo.programId=new K("Stake11111111111111111111111111111111111111");Vo.space=200;class Gf{constructor(e,t,n,s){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=s}}class Zw{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=ee("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(un))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a VoteInstruction");return s}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=Re(un.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Gf(new K(t.nodePubkey),new K(t.authorizedVoter),new K(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:n}=Re(un.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new K(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:s,voteAuthorizationType:o}}=Re(un.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new K(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new K(s),voteAuthorizationType:{index:o},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=Re(un.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(rs.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const un=Object.freeze({InitializeAccount:{index:0,layout:te([ee("instruction"),Xy()])},Authorize:{index:1,layout:te([ee("instruction"),we("newAuthorized"),ee("voteAuthorizationType")])},Withdraw:{index:3,layout:te([ee("instruction"),Ct("lamports")])},UpdateValidatorIdentity:{index:4,layout:te([ee("instruction")])},AuthorizeWithSeed:{index:10,layout:te([ee("instruction"),Jy()])}}),Xw=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class rs{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:n,voteInit:s}=e,o=un.InitializeAccount,i=ke(o,{voteInit:{nodePubkey:de(s.nodePubkey.toBuffer()),authorizedVoter:de(s.authorizedVoter.toBuffer()),authorizedWithdrawer:de(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Wr,isSigner:!1,isWritable:!1},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new Pe(a)}static createAccount(e){const t=new _e;return t.add(st.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,voteAuthorizationType:o}=e,i=un.Authorize,a=ke(i,{newAuthorized:de(s.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new _e().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=un.AuthorizeWithSeed,u=ke(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:de(n.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:de(o.toBuffer()),voteAuthorizationType:i.index}}),l=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:on,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new _e().add({keys:l,programId:this.programId,data:u})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:s,toPubkey:o}=e,i=un.Withdraw,a=ke(i,{lamports:s}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new _e().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return rs.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:s}=e,o=un.UpdateValidatorIdentity,i=ke(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new _e().add({keys:a,programId:this.programId,data:i})}}rs.programId=new K("Vote111111111111111111111111111111111111111");rs.space=3762;const Yf=new K("Va1idator1nfo111111111111111111111111111111"),Jw=z({name:M(),website:ce(M()),details:ce(M()),iconUrl:ce(M()),keybaseUsername:ce(M())});class rc{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(Rt(t)!==2)return null;const s=[];for(let o=0;o<2;o++){const i=new K(Lt(t,0,ln)),a=an(t)===1;s.push({publicKey:i,isSigner:a})}if(s[0].publicKey.equals(Yf)&&s[1].isSigner){const o=nr().decode(O.Buffer.from(t)),i=JSON.parse(o);return lf(i,Jw),new rc(s[1].publicKey,i)}return null}}const Qw=new K("Vote111111111111111111111111111111111111111"),em=te([we("nodePubkey"),we("authorizedWithdrawer"),Se("commission"),lt(),pt(te([lt("slot"),ee("confirmationCount")]),qn(ee(),-8),"votes"),Se("rootSlotValid"),lt("rootSlot"),lt(),pt(te([lt("epoch"),we("authorizedVoter")]),qn(ee(),-8),"authorizedVoters"),te([pt(te([we("authorizedPubkey"),lt("epochOfLastAuthorizedSwitch"),lt("targetEpoch")]),32,"buf"),lt("idx"),Se("isEmpty")],"priorVoters"),lt(),pt(te([lt("epoch"),lt("credits"),lt("prevCredits")]),qn(ee(),-8),"epochCredits"),te([lt("slot"),lt("timestamp")],"lastTimestamp")]);class sc{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const n=em.decode(de(e),4);let s=n.rootSlot;return n.rootSlotValid||(s=null),new sc({nodePubkey:new K(n.nodePubkey),authorizedWithdrawer:new K(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:s,authorizedVoters:n.authorizedVoters.map(tm),priorVoters:nm(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}}function tm({authorizedVoter:r,epoch:e}){return{epoch:e,authorizedVoter:new K(r)}}function fu({authorizedPubkey:r,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new K(r),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function nm({buf:r,idx:e,isEmpty:t}){return t?[]:[...r.slice(e+1).map(fu),...r.slice(0,e).map(fu)]}const du={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function rm(r,e){const t=e===!1?"http":"https";if(!r)return du[t].devnet;const n=du[t][r];if(!n)throw new Error(`Unknown ${t} cluster: ${r}`);return n}async function sm(r,e,t,n){let s,o;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(s=t,o=n):o=t;const i=o&&{skipPreflight:o.skipPreflight,preflightCommitment:o.preflightCommitment||o.commitment,minContextSlot:o.minContextSlot},a=await r.sendRawTransaction(e,i),c=o&&o.commitment,l=(await(s?r.confirmTransaction(s,c):r.confirmTransaction(a,c))).value;if(l.err)throw a!=null?new Is({action:i!=null&&i.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(l)})`}):new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);return a}const om=1e9,im=Object.freeze(Object.defineProperty({__proto__:null,Account:jy,AddressLookupTableAccount:Xi,AddressLookupTableInstruction:Kw,AddressLookupTableProgram:tc,Authorized:Vf,BLOCKHASH_CACHE_TIMEOUT_MS:Of,BPF_LOADER_DEPRECATED_PROGRAM_ID:Vy,BPF_LOADER_PROGRAM_ID:hb,BpfLoader:pb,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:cn,ComputeBudgetInstruction:Ww,ComputeBudgetProgram:nc,Connection:Hw,Ed25519Program:jo,Enum:Wy,EpochSchedule:Pf,FeeCalculatorLayout:Tf,Keypair:Cr,LAMPORTS_PER_SOL:om,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:_n,Loader:hr,Lockup:zs,MAX_SEED_LENGTH:Bf,Message:Qt,MessageAccountKeys:Es,MessageV0:dr,NONCE_ACCOUNT_LENGTH:Zi,NonceAccount:Ko,PACKET_DATA_SIZE:jn,PUBLIC_KEY_LENGTH:ln,PublicKey:K,SIGNATURE_LENGTH_IN_BYTES:xs,SOLANA_SCHEMA:gs,STAKE_CONFIG_ID:jf,STAKE_INSTRUCTION_LAYOUTS:rt,SYSTEM_INSTRUCTION_LAYOUTS:Oe,SYSVAR_CLOCK_PUBKEY:on,SYSVAR_EPOCH_SCHEDULE_PUBKEY:rb,SYSVAR_INSTRUCTIONS_PUBKEY:sb,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:Zs,SYSVAR_RENT_PUBKEY:Wr,SYSVAR_REWARDS_PUBKEY:ob,SYSVAR_SLOT_HASHES_PUBKEY:ib,SYSVAR_SLOT_HISTORY_PUBKEY:ab,SYSVAR_STAKE_HISTORY_PUBKEY:Xs,Secp256k1Program:Or,SendTransactionError:Is,SolanaJSONRPCError:ne,SolanaJSONRPCErrorCode:cb,StakeAuthorizationLayout:Yw,StakeInstruction:Gw,StakeProgram:Vo,Struct:ja,SystemInstruction:fb,SystemProgram:st,Transaction:_e,TransactionExpiredBlockheightExceededError:Va,TransactionExpiredNonceInvalidError:Tr,TransactionExpiredTimeoutError:Ga,TransactionInstruction:Pe,TransactionMessage:Za,TransactionStatus:Sn,VALIDATOR_INFO_KEY:Yf,VERSION_PREFIX_MASK:Mo,VOTE_PROGRAM_ID:Qw,ValidatorInfo:rc,VersionedMessage:Ya,VersionedTransaction:Xa,VoteAccount:sc,VoteAuthorizationLayout:Xw,VoteInit:Gf,VoteInstruction:Zw,VoteProgram:rs,clusterApiUrl:rm,sendAndConfirmRawTransaction:sm,sendAndConfirmTransaction:Yi},Symbol.toStringTag,{value:"Module"})),a2=Bs(im);export{Te as P,Wr as S,fm as _,e2 as a,K as b,st as c,on as d,Dr as e,Ze as f,ut as n,sr as o,a2 as r,ie as s,oe as u};
